<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUGARMIX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sugarmix.me/"/>
  <updated>2020-12-25T05:31:15.993Z</updated>
  <id>https://blog.sugarmix.me/</id>
  
  <author>
    <name>sugarmix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《鲁迅全集》摘抄</title>
    <link href="https://blog.sugarmix.me/20201225125556/"/>
    <id>https://blog.sugarmix.me/20201225125556/</id>
    <published>2020-12-25T04:55:57.000Z</published>
    <updated>2020-12-25T05:31:15.993Z</updated>
    
    <content type="html"><![CDATA[<p>谁曾想一个工科学生在将来的某一天重读鲁迅，并愿意把它记录下来。</p><a id="more"></a><p>《端午节》</p><blockquote><p>人们是每苦于没有“自知之明”的。</p></blockquote><p>《影的告别》</p><blockquote><p>我不过一个影，要别你而沉默在黑暗里了。而然黑暗又会吞并我，然而光明又会使我消失。</p></blockquote><p>《希望》</p><blockquote><p>希望是甚么？是娼妓：她对谁都蛊惑，将一切都献给；待你牺牲了极多的宝贝——你的青春——她就弃掉你。</p></blockquote><p>《过客》</p><blockquote><p>倘使我得到了谁的布施，我就要想秃鹰看见死尸一样，在四近徘徊，祝愿她的灭亡，给我亲眼看见；或者诅咒她以外的一切全部灭亡，连我自己，因为我就应该得到诅咒。但我还没有这样的力量；即使有这力量，我也不愿意她有这样的境遇，因为他们大概总不愿意有这样的境遇。</p></blockquote><p>《随感录四十一》</p><blockquote><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。  </p><p>此后如竟没有炬火：我便是唯一的光。</p></blockquote><p>《六十二 恨恨而死》</p><blockquote><p>古来很有几位恨恨而死的人物。他们一面说些“怀才不遇”，“天道宁论”的话，一面有钱的便狂嫖滥赌，没钱的便喝几十碗酒，——因为不平的缘故，于是后来就恨恨而死了。</p><p>我们应该趁他们活着的时候问他：诸公！您知道北京离昆仑山几里，弱水去黄河几丈么？火药除了做鞭炮，罗盘除了看风水，还有什么用处么？棉花是红的还是白的？谷子是长在树上，还是长在草上？桑见濮上如何情形，自由恋爱怎样态度？您在半夜里可忽然觉得有些羞，清早上可居然有点悔么？四斤的担，您能挑么？三里的道，您能跑么？</p><p>他们如果细细的想，慢慢的悔了，这便很有些希望。万一越发不平，越发愤怒，那便“爱莫能助”。——于是他们终于恨恨而死了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;谁曾想一个工科学生在将来的某一天重读鲁迅，并愿意把它记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/tags/%E9%BB%98%E8%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Super Egg Drop</title>
    <link href="https://blog.sugarmix.me/20190315095242/"/>
    <id>https://blog.sugarmix.me/20190315095242/</id>
    <published>2019-03-15T01:52:51.000Z</published>
    <updated>2020-05-17T17:13:38.639Z</updated>
    
    <content type="html"><![CDATA[<p>鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><h1 id="正面解决"><a href="#正面解决" class="headerlink" title="正面解决"></a>正面解决</h1><p>即根据题目意思直接计算 F</p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>可以确定算法正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 没有鸡蛋或者没有楼层的时候肯定是 0  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 仅有一个鸡蛋，只能从最底层开始尝试，有几层就要尝试几次 */</span></span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 尝试最底层，如果鸡蛋没碎，确定结果；如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-1个楼层 */</span></span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * 尝试第i+1层，如果鸡蛋没碎，则问题转化为K个鸡蛋探索i层，即第一层到第i层(i-1+1)；</span></span><br><span class="line"><span class="comment">                 * 如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-i-1个楼层，即第i+2层到N层(N-(i+2)+1)；</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=3,N=26</p></blockquote><p>不出意外的超时了。</p><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>分析上述算法超时的原因，存在太多重复的递归运算，使用备忘录消除重复计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 备忘录 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] note = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.note[K][N] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果曾经计算过直接返回 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.note[K][N];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 返回前保存计算的值 */</span></span><br><span class="line">        <span class="keyword">this</span>.note[K][N] = t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=6,N=2000</p></blockquote><p>原本以为这样可以不优雅的通过，然而却依旧超时。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p>上述算法虽然消除了重复的递归运算，但依旧存在大量递归，递归本身消耗的时间太多，使用动态规划填表的方式消除递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 二维数组初始值为0 */</span></span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化1个鸡蛋i层楼尝试i次的情况 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化i个鸡蛋在1层楼尝试1次的情况 */</span></span><br><span class="line">            table[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始填表，思路同递归算法 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= N; n++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(table[k][<span class="number">0</span>], table[k - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                table[k][n] = t + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[K][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=7,N=10000</p></blockquote><p>意外的超时了。</p><h2 id="减少遍历"><a href="#减少遍历" class="headerlink" title="减少遍历"></a>减少遍历</h2><p>此处存在大量无价值的遍历，考虑到随着i增加，<code>table[k][i]</code>,<code>table[k - 1][n - i - 1]</code>分别单调增加和减少，故其两个中较大值，一定出现在中间位置。可以使用二分法找出最合适的<code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h1><p>K个鸡蛋，尝试M次，最多可以尝试到的楼层个数为<code>table[K][M]</code>。尝试某一层，若在该层碎了，则使用<code>K-1</code>个鸡蛋探索<code>M-1</code>次，若没碎，使用<code>K</code>个鸡蛋探索<code>M-1</code>次，当前探索的本层为<code>1</code>。虽然不知道尝试的哪一层，但是知道存在某一层，尝试后会得到的结果为<code>table[K][M]</code>。<br>当 <code>table[k][m-1] &lt; F &lt;= table[k][m]</code> 时，m即为探索的次数，注意鸡蛋可能给多了所以使用k而不是K，其中k&lt;=K。此时需要预估最大尝试次数M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = N;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="comment">/* 1个鸡蛋尝试i次 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">/* j个鸡蛋尝试1次 */</span></span><br><span class="line">            table[j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 策略是：尽可能的多使用鸡蛋，少使用尝试次数</span></span><br><span class="line"><span class="comment">         * 故遍历时，内层遍历鸡蛋，让鸡蛋先用完，</span></span><br><span class="line"><span class="comment">         * 外层遍历尝试次数，不得已的时候增加尝试次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                table[j][i] = table[j - <span class="number">1</span>][i - <span class="number">1</span>] + table[j][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[j][i] &gt;= N) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 楼层数为1,或鸡蛋数为1时会走到这里</span></span><br><span class="line"><span class="comment">         * 楼层数为1时返回1，鸡蛋数为1时返回楼层数</span></span><br><span class="line"><span class="comment">         * 综上返回楼层数即可</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，问题终于解决。最棒的情况是可以独立快速的解决问题，在认真思考后依旧不能给出合适的答案时，寻求帮助也是个不错的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Super Egg Drop</a><br><a href="https://www.cnblogs.com/Phantom01/p/9490508.html" target="_blank" rel="noopener">Leetcode 887 Super Egg Drop(扔鸡蛋) DP</a><br><a href="https://leetcode.com/problems/super-egg-drop/solution/" target="_blank" rel="noopener">Super Egg Drop Solution</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.sugarmix.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://blog.sugarmix.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈交叉编译</title>
    <link href="https://blog.sugarmix.me/20200407163610/"/>
    <id>https://blog.sugarmix.me/20200407163610/</id>
    <published>2020-04-07T08:36:11.000Z</published>
    <updated>2020-04-21T15:55:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。</p><a id="more"></a><h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>首先简化编译的概念，这里不提编译预处理、词法分析、语法分析等等一系列的概念，<del>因为我也不知道自己是不是真的懂这些东西</del>，想了解这部分概念，可以去看编译原理相关的书籍。</p><p>这里把<strong>编译</strong>简单的理解为<strong>从一种字符串</strong>（例如C语言的源程序）到<strong>另一种字符串</strong>（与机器相关的二进制01字符串）的<strong>转化</strong>。</p><p>进行转化操作的，一般来说是一个软件（我们不应该忘记曾经在纸带上打孔的科学家们，他们将想法变成纸带上孔的过程，难道不是编译所做的事情吗），这个软件被称为编译器。</p><ul><li>一般情况下，写一段C程序，通过运行在x86机器上的编译器，编译出一个可以在x86上运行的程序。  </li><li>另一种情况，还是那一段C程序，通过运行在AArch64机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>这体现了C语言良好的跨平台特性，一段代码只需要分别编译就可以在两种架构的设备上运行。</p><p>然而，假如你现在手上的AArch64的机器内存很小，没有硬盘，它能做的事情只是以很低的功耗运行一些小型的软件，或者以任何理由导致它没有运行起一个编译器的能力，而凑巧的是，你手头正好有一个可以用来编译的x86机器。（如果这个也没有，那你真的是太惨了）</p><p>现在第三种情况出现了</p><ul><li>还是刚才那段C程序，通过运行在x86机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>上面这个编译器，就被称为<strong>交叉编译器</strong>，这种情况，就被称为<strong>交叉编译</strong>。很显然，交叉编译器编译出的二进制文件没有办法在这台编译出它的机器上运行。</p><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>当我开开心心的把编译好的软件（此处应该理解为可执行文件），放到AArch64机器上运行的时候，告诉我缺少<code>lib*.so*</code>。出现这种情况<strong>一般</strong>是在编译时链接进来的库文件在目标系统（就是那个啥都没有还想运行软件的系统）上缺失。<br>一种方案是直接使用静态链接，这种方案不推荐。首要原因可以参考<a href="https://blog.lilydjwg.me/2015/5/11/why-i-m-against-static-linking.92218.html" target="_blank" rel="noopener">为什么我反对普遍地静态链接？-依云&#39;s Blog</a>，其次是，静态链接你真不见得编译的过 ;-)</p><h1 id="动态链接库的查找方式"><a href="#动态链接库的查找方式" class="headerlink" title="动态链接库的查找方式"></a>动态链接库的查找方式</h1><p>既然我们<del>菜的没法通过静态链接，</del>理智的接受了别人推荐的动态链接，那么就有必要知道二进制程序在运行时是如何查找所需要的链接库的。</p><p>直接放（在Linux可用的）结论。排名分先后</p><ol><li><p>Linux中二进制文件使用ELF格式，其中包含RPATH变量，这个变量指向一个路径，这个路径是这个二进制文件查找so的路径。在链接时可以通过环境变量或者编译参数影响这个变量，这是最稳妥也最有效果的方式，但是需要在编译时就确定好目录，如果程序已经编译完了，懒得再次编译或者无法再次编译，就不能用这个方法了</p></li><li><p>如果上一个步骤没有找到链接库，同时又设置了LD_LIBRARY_PATH环境变量，那么会在这个环境变量指向的路径中查找。这是我个人最常用也最喜欢的方式，使用的时候甚至不需要export，而是直接加在命令前面，可以把影响范围缩小到仅一条命令</p></li><li><p>第三种是使用/etc/ld.so.conf，在第二种方式查找失败的时候会使用中指定的路径</p></li></ol><p>除了第一种，剩下两种都有一定的约束条件，毕竟平白无辜设置一个环境变量二进制程序也不会去直接读。那么就要简单的说一下后两种是怎么生效的。在理解生效方式后，也就理解为什么也可以把so直接放到/lib或者/usr/lib里了。</p><p>算了，我懒了，这里直接贴<a href="http://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener">man ld.so</a>的输出</p><blockquote><p>When resolving shared object dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (this can occur if a shared object pathname containing slashes was specified at link time).  If a slash is found, then the dependency string is interpreted as a (relative or absolute) pathname, and the shared object is loaded using that pathname.</p><p> If a shared object dependency does not contain a slash, then it is searched for in the following order:</p><ul><li><p>Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist.  Use of DT_RPATH is deprecated.</p></li><li><p>Using the environment variable LD_LIBRARY_PATH, unless the executable is being run in secure-execution mode (see below), in which case this variable is ignored.</p></li><li><p>Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present.  Such directories are searched only to find those objects required by DT_NEEDED (direct dependencies) entries and do not apply to those objects&#39; children, which must themselves have their own DT_RUNPATH entries.  This is unlike DT_RPATH, which is applied to searches for all children in the dependency tree.</p></li><li><p>From the cache file /etc/ld.so.cache, which contains a compiled list of candidate shared objects previously found in the augmented library path.  If, however, the binary was linked with the -z nodeflib linker option, shared objects in the default paths are skipped.  Shared objects installed in hardware capability directories (see below) are preferred to other shared objects.</p></li><li><p>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</p></li></ul></blockquote><p>其中，刷新/etc/ld.so.cache的是/sbin/ldconfig。</p><p>手册可真是个好东西呀，这篇文章只是粗略的描述了一下，需要了解细节可以通过手册一层一层的查下去了。</p><p>本文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关系模式符合的范式</title>
    <link href="https://blog.sugarmix.me/20180319190418/"/>
    <id>https://blog.sugarmix.me/20180319190418/</id>
    <published>2018-03-19T11:04:18.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。</p><a id="more"></a><h1 id="按规范设计的好处"><a href="#按规范设计的好处" class="headerlink" title="按规范设计的好处"></a>按规范设计的好处</h1><p>减少冗余。设计不良的数据表，存在大量冗余数据，这些数据浪费磁盘空间，还会影响数据修改的效率。下文讲看到冗余的例子。</p><p>增强一致性。存在冗余数据越多，越容易造成数据不一致。接下来将逐渐增强对一致性的要求，不同层次的要求就出现了不同的范式。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><h2 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h2><p>若关系中的某一 <strong>属性组</strong> 的值能唯一的标识一个元组,而其任何真子集都不能再标识,则称该属性组为候选码。下文中不加解释的 <strong>码</strong> 即为候选码。</p><h2 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h2><p>包含在任意候选码中的属性</p><h2 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h2><p><a href="#候选码">候选码</a>中任选一组，均可作为主码。</p><h2 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h2><p>不包含在主码中的属性，选定主码后确定非主属性。</p><p><em><strong> 非主属性 不等于 不是主属性的属性 </strong></em></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>B可以由A导出.则B依赖A</p><p>$$<br>A \to B<br>$$</p><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>B可以由A导出,并且不能由A的任意子集导出,则B完全函数依赖A</p><p>$$<br>(A \to B)\land(\lnot((\exists C \subsetneq A)\land(C \to B)))<br>$$</p><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>B可以由A导出,并且能由A的某个真子集导出,则B部分函数依赖A</p><p>$$<br>(A \to B)\land((\exists C \subsetneq B)\land(C \to B))<br>$$</p><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>B可以由A导出,C可以由B导出,则C传递函数依赖A</p><p>$$<br>(A \to B)\land(B \to C)<br>$$</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>域都应该是原子性的</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假如属性存在以下依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学号 → 学生姓名</span><br><span class="line">课程号 → 课程名 → 教材</span><br><span class="line">(学号,课程名) → 分数</span><br></pre></td></tr></table></figure><p>能放到数据库的信息都符合第一范式,下面给出一个符合第一范式的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成绩(学号,学生姓名,课程号,课程名,教材,分数)</span><br></pre></td></tr></table></figure><p>根据定义<br>主码:(学号,课程号)<br>非主属性:学生姓名,课程名,教材,分数</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在第一范式的基础上，非码属性必须完全依赖于<a href="#候选码">候选码</a>(在第一范式基础上消除<a href="#非主属性">非主属性</a>对<a href="#主码">主码</a>的<a href="#部分函数依赖">部分函数依赖</a>)</p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>学生姓名依赖学号却不依赖课程号,所以非主属性(学生姓名)部分依赖主码(学号,课程号).<br>修改第一范式的例子使其符合第二范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>任何非主属性不依赖于其它非主属性（在第二范式基础上消除<a href="#传递函数依赖">传递依赖</a>）</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p>在第二范式中的<code>课程(课程号,课程名,教材)</code>存在<code>课程号 → 课程名 → 教材</code>依赖关系,非主属性(教材)传递依赖非主属性(课程号).<br>修改例子使其满足第三范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名)</span><br><span class="line">教材(课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>在第三范式基础上，任何非主属性(其中包含主属性,神奇不神奇)不能对主码子集依赖(在第三范式基础上消除对主码子集的依赖).</p><p>知乎上大佬给出的一个更精确的定义:消除主属性对于码的部分与传递函数依赖.</p><p>因为第三范式已经解决其他依赖,此处只要解决那些原本可以被选为<strong>主码</strong>却沦为了<strong>非主属性</strong>的的<strong>主属性</strong>们,也就是说,此时,<strong>非主属性</strong>依旧是<strong>主属性</strong>.</p><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><p>下面这个例子抄自<a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">知乎</a><br>某公司有若干个仓库:</p><blockquote><p>每个仓库只能有一名管理员<br>一名管理员只能在一个仓库中工作<br>一个仓库中可以存放多种物品<br>一种物品也可以存放在不同的仓库中<br>每种物品在每个仓库中都有对应的数量</p></blockquote><p>关系<code>仓库(仓库名,管理员,物品名,数量)</code>符合第三范式</p><p>仓库 → 管理员<br>管理员 → 仓库<br>(仓库名,物品名) → 数量</p><p>若选(仓库名,物品名)为主码,则主属性(管理员)部分依赖主码(依赖主码中的仓库名)</p><p>修改关系使其符合BC范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仓库（仓库名，管理员）</span><br><span class="line">库存（仓库名，物品名，数量）</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">解释一下关系数据库的第一第二第三范式？ - 刘慰的回答 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>批量修改Hexo文件名</title>
    <link href="https://blog.sugarmix.me/20181229230044/"/>
    <id>https://blog.sugarmix.me/20181229230044/</id>
    <published>2018-12-29T15:00:44.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知Hexo是个纯静态页面生成工具，使用<code>hexo new title</code>可生成标题为title的文章。若文章题目中出现中文，编码后肉眼不可识别中文意思；若不转码，中文作为url的一部分总会出现种种问题。本文将阐述解决上述问题的方法。</p><a id="more"></a><p>第一种，在创建文章的时候有意识的使用英文标题。第二中，使用当前时间作为文件名(即URL中的地址)，新建文件后再从文件中修改标题。</p><p>本文对第二种方法进行介绍，使用脚本创建新文章，注意时间是精确到秒，该脚本放在博客的根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=date +%Y%m%d%H%M%S</span><br><span class="line">hexo new <span class="string">"<span class="variable">$DATE</span>"</span></span><br><span class="line">vim <span class="built_in">source</span>/_posts/<span class="variable">$DATE</span>.md</span><br></pre></td></tr></table></figure><p>但是问题来了，如果已经写了很多很多的文章了，而且想批量修改成上述格式怎么办呢？下面给出批量修改文件名的脚本，将此脚本放到<code>_post</code>目录，执行即可，最终文件的格式将与上述格式相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ls | grep <span class="string">".md"</span> &gt; filename.txt</span><br><span class="line">num=`cat filename.txt|wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Start"</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=<span class="variable">$num</span>;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    filename=`cat filename.txt|awk NR==<span class="variable">$i</span>`</span><br><span class="line">    date=`cat <span class="variable">$filename</span>|grep <span class="string">"date: "</span>`</span><br><span class="line"></span><br><span class="line">    year=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 7-10`</span><br><span class="line">    mon=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 12-13`</span><br><span class="line">    day=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 15-16`</span><br><span class="line">    hour=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 18-19`</span><br><span class="line">    min=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 21-22`</span><br><span class="line">    sec=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 24-25`</span><br><span class="line"></span><br><span class="line">    oldname=`<span class="built_in">echo</span> <span class="variable">$&#123;filename%.md&#125;</span>`</span><br><span class="line">    newname=<span class="variable">$year</span><span class="variable">$mon</span><span class="variable">$day</span><span class="variable">$hour</span><span class="variable">$min</span><span class="variable">$sec</span></span><br><span class="line"></span><br><span class="line">    mv <span class="variable">$oldname</span> <span class="variable">$newname</span></span><br><span class="line">    mv <span class="variable">$oldname</span>.md <span class="variable">$newname</span>.md</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Renamed Number: <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Done"</span></span><br></pre></td></tr></table></figure><p>执行此脚本时，同时会重命名放图片的文件夹，若该文件夹不存在，则会有一系列输出，正常情况不要慌。</p><p>此时默认生成的链接里，会出现两部分日期，修改配置文件<code>_config.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :title/</span><br></pre></td></tr></table></figure><p>因为修改了文章链接，所有依赖链接工作的工具都会收影响，比如访客计数，评论系统等等。</p><p>最后提一句，不要在Telegram里直接保存代码，bash中的反引号会被处理掉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知Hexo是个纯静态页面生成工具，使用&lt;code&gt;hexo new title&lt;/code&gt;可生成标题为title的文章。若文章题目中出现中文，编码后肉眼不可识别中文意思；若不转码，中文作为url的一部分总会出现种种问题。本文将阐述解决上述问题的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="网站" scheme="https://blog.sugarmix.me/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站" scheme="https://blog.sugarmix.me/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
