<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUGARMIX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sugarmix.me/"/>
  <updated>2020-05-17T17:13:38.639Z</updated>
  <id>https://blog.sugarmix.me/</id>
  
  <author>
    <name>sugarmix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Super Egg Drop</title>
    <link href="https://blog.sugarmix.me/20190315095242/"/>
    <id>https://blog.sugarmix.me/20190315095242/</id>
    <published>2019-03-15T01:52:51.000Z</published>
    <updated>2020-05-17T17:13:38.639Z</updated>
    
    <content type="html"><![CDATA[<p>鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><h1 id="正面解决"><a href="#正面解决" class="headerlink" title="正面解决"></a>正面解决</h1><p>即根据题目意思直接计算 F</p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>可以确定算法正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 没有鸡蛋或者没有楼层的时候肯定是 0  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 仅有一个鸡蛋，只能从最底层开始尝试，有几层就要尝试几次 */</span></span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 尝试最底层，如果鸡蛋没碎，确定结果；如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-1个楼层 */</span></span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * 尝试第i+1层，如果鸡蛋没碎，则问题转化为K个鸡蛋探索i层，即第一层到第i层(i-1+1)；</span></span><br><span class="line"><span class="comment">                 * 如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-i-1个楼层，即第i+2层到N层(N-(i+2)+1)；</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=3,N=26</p></blockquote><p>不出意外的超时了。</p><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>分析上述算法超时的原因，存在太多重复的递归运算，使用备忘录消除重复计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 备忘录 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] note = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.note[K][N] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果曾经计算过直接返回 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.note[K][N];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 返回前保存计算的值 */</span></span><br><span class="line">        <span class="keyword">this</span>.note[K][N] = t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=6,N=2000</p></blockquote><p>原本以为这样可以不优雅的通过，然而却依旧超时。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p>上述算法虽然消除了重复的递归运算，但依旧存在大量递归，递归本身消耗的时间太多，使用动态规划填表的方式消除递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 二维数组初始值为0 */</span></span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化1个鸡蛋i层楼尝试i次的情况 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化i个鸡蛋在1层楼尝试1次的情况 */</span></span><br><span class="line">            table[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始填表，思路同递归算法 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= N; n++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(table[k][<span class="number">0</span>], table[k - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                table[k][n] = t + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[K][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=7,N=10000</p></blockquote><p>意外的超时了。</p><h2 id="减少遍历"><a href="#减少遍历" class="headerlink" title="减少遍历"></a>减少遍历</h2><p>此处存在大量无价值的遍历，考虑到随着i增加，<code>table[k][i]</code>,<code>table[k - 1][n - i - 1]</code>分别单调增加和减少，故其两个中较大值，一定出现在中间位置。可以使用二分法找出最合适的<code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h1><p>K个鸡蛋，尝试M次，最多可以尝试到的楼层个数为<code>table[K][M]</code>。尝试某一层，若在该层碎了，则使用<code>K-1</code>个鸡蛋探索<code>M-1</code>次，若没碎，使用<code>K</code>个鸡蛋探索<code>M-1</code>次，当前探索的本层为<code>1</code>。虽然不知道尝试的哪一层，但是知道存在某一层，尝试后会得到的结果为<code>table[K][M]</code>。<br>当 <code>table[k][m-1] &lt; F &lt;= table[k][m]</code> 时，m即为探索的次数，注意鸡蛋可能给多了所以使用k而不是K，其中k&lt;=K。此时需要预估最大尝试次数M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = N;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="comment">/* 1个鸡蛋尝试i次 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">/* j个鸡蛋尝试1次 */</span></span><br><span class="line">            table[j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 策略是：尽可能的多使用鸡蛋，少使用尝试次数</span></span><br><span class="line"><span class="comment">         * 故遍历时，内层遍历鸡蛋，让鸡蛋先用完，</span></span><br><span class="line"><span class="comment">         * 外层遍历尝试次数，不得已的时候增加尝试次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                table[j][i] = table[j - <span class="number">1</span>][i - <span class="number">1</span>] + table[j][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[j][i] &gt;= N) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 楼层数为1,或鸡蛋数为1时会走到这里</span></span><br><span class="line"><span class="comment">         * 楼层数为1时返回1，鸡蛋数为1时返回楼层数</span></span><br><span class="line"><span class="comment">         * 综上返回楼层数即可</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，问题终于解决。最棒的情况是可以独立快速的解决问题，在认真思考后依旧不能给出合适的答案时，寻求帮助也是个不错的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Super Egg Drop</a><br><a href="https://www.cnblogs.com/Phantom01/p/9490508.html" target="_blank" rel="noopener">Leetcode 887 Super Egg Drop(扔鸡蛋) DP</a><br><a href="https://leetcode.com/problems/super-egg-drop/solution/" target="_blank" rel="noopener">Super Egg Drop Solution</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.sugarmix.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://blog.sugarmix.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈交叉编译</title>
    <link href="https://blog.sugarmix.me/20200407163610/"/>
    <id>https://blog.sugarmix.me/20200407163610/</id>
    <published>2020-04-07T08:36:11.000Z</published>
    <updated>2020-04-21T15:55:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。</p><a id="more"></a><h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>首先简化编译的概念，这里不提编译预处理、词法分析、语法分析等等一系列的概念，<del>因为我也不知道自己是不是真的懂这些东西</del>，想了解这部分概念，可以去看编译原理相关的书籍。</p><p>这里把<strong>编译</strong>简单的理解为<strong>从一种字符串</strong>（例如C语言的源程序）到<strong>另一种字符串</strong>（与机器相关的二进制01字符串）的<strong>转化</strong>。</p><p>进行转化操作的，一般来说是一个软件（我们不应该忘记曾经在纸带上打孔的科学家们，他们将想法变成纸带上孔的过程，难道不是编译所做的事情吗），这个软件被称为编译器。</p><ul><li>一般情况下，写一段C程序，通过运行在x86机器上的编译器，编译出一个可以在x86上运行的程序。  </li><li>另一种情况，还是那一段C程序，通过运行在AArch64机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>这体现了C语言良好的跨平台特性，一段代码只需要分别编译就可以在两种架构的设备上运行。</p><p>然而，假如你现在手上的AArch64的机器内存很小，没有硬盘，它能做的事情只是以很低的功耗运行一些小型的软件，或者以任何理由导致它没有运行起一个编译器的能力，而凑巧的是，你手头正好有一个可以用来编译的x86机器。（如果这个也没有，那你真的是太惨了）</p><p>现在第三种情况出现了</p><ul><li>还是刚才那段C程序，通过运行在x86机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>上面这个编译器，就被称为<strong>交叉编译器</strong>，这种情况，就被称为<strong>交叉编译</strong>。很显然，交叉编译器编译出的二进制文件没有办法在这台编译出它的机器上运行。</p><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>当我开开心心的把编译好的软件（此处应该理解为可执行文件），放到AArch64机器上运行的时候，告诉我缺少<code>lib*.so*</code>。出现这种情况<strong>一般</strong>是在编译时链接进来的库文件在目标系统（就是那个啥都没有还想运行软件的系统）上缺失。<br>一种方案是直接使用静态链接，这种方案不推荐。首要原因可以参考<a href="https://blog.lilydjwg.me/2015/5/11/why-i-m-against-static-linking.92218.html" target="_blank" rel="noopener">为什么我反对普遍地静态链接？-依云&#39;s Blog</a>，其次是，静态链接你真不见得编译的过 ;-)</p><h1 id="动态链接库的查找方式"><a href="#动态链接库的查找方式" class="headerlink" title="动态链接库的查找方式"></a>动态链接库的查找方式</h1><p>既然我们<del>菜的没法通过静态链接，</del>理智的接受了别人推荐的动态链接，那么就有必要知道二进制程序在运行时是如何查找所需要的链接库的。</p><p>直接放（在Linux可用的）结论。排名分先后</p><ol><li><p>Linux中二进制文件使用ELF格式，其中包含RPATH变量，这个变量指向一个路径，这个路径是这个二进制文件查找so的路径。在链接时可以通过环境变量或者编译参数影响这个变量，这是最稳妥也最有效果的方式，但是需要在编译时就确定好目录，如果程序已经编译完了，懒得再次编译或者无法再次编译，就不能用这个方法了</p></li><li><p>如果上一个步骤没有找到链接库，同时又设置了LD_LIBRARY_PATH环境变量，那么会在这个环境变量指向的路径中查找。这是我个人最常用也最喜欢的方式，使用的时候甚至不需要export，而是直接加在命令前面，可以把影响范围缩小到仅一条命令</p></li><li><p>第三种是使用/etc/ld.so.conf，在第二种方式查找失败的时候会使用中指定的路径</p></li></ol><p>除了第一种，剩下两种都有一定的约束条件，毕竟平白无辜设置一个环境变量二进制程序也不会去直接读。那么就要简单的说一下后两种是怎么生效的。在理解生效方式后，也就理解为什么也可以把so直接放到/lib或者/usr/lib里了。</p><p>算了，我懒了，这里直接贴<a href="http://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener">man ld.so</a>的输出</p><blockquote><p>When resolving shared object dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (this can occur if a shared object pathname containing slashes was specified at link time).  If a slash is found, then the dependency string is interpreted as a (relative or absolute) pathname, and the shared object is loaded using that pathname.</p><p> If a shared object dependency does not contain a slash, then it is searched for in the following order:</p><ul><li><p>Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist.  Use of DT_RPATH is deprecated.</p></li><li><p>Using the environment variable LD_LIBRARY_PATH, unless the executable is being run in secure-execution mode (see below), in which case this variable is ignored.</p></li><li><p>Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present.  Such directories are searched only to find those objects required by DT_NEEDED (direct dependencies) entries and do not apply to those objects&#39; children, which must themselves have their own DT_RUNPATH entries.  This is unlike DT_RPATH, which is applied to searches for all children in the dependency tree.</p></li><li><p>From the cache file /etc/ld.so.cache, which contains a compiled list of candidate shared objects previously found in the augmented library path.  If, however, the binary was linked with the -z nodeflib linker option, shared objects in the default paths are skipped.  Shared objects installed in hardware capability directories (see below) are preferred to other shared objects.</p></li><li><p>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</p></li></ul></blockquote><p>其中，刷新/etc/ld.so.cache的是/sbin/ldconfig。</p><p>手册可真是个好东西呀，这篇文章只是粗略的描述了一下，需要了解细节可以通过手册一层一层的查下去了。</p><p>本文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>霍夫变换检测原理及Python实现</title>
    <link href="https://blog.sugarmix.me/20180415221531/"/>
    <id>https://blog.sugarmix.me/20180415221531/</id>
    <published>2018-04-15T14:15:31.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>随着人工智能的兴起，计算机视觉相关概念，如人脸识别、人脸检测逐渐进入大众视野。本篇文章介绍计算机视觉中最基础的知识，直线和圆的一种检测算法-霍夫变换。并在最后给出Python的样例代码。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>霍夫变换用来检测物图像中的特征(例如直线和圆).算法如下：</p><blockquote><p>根据被检测的图形，寻找特定的参数空间<br>原图像中所有的点在参数空间中执行投票,投票结果最大的点，即为要寻找的图形</p></blockquote><p>根据上面的描述不难看出,一般情况下：</p><blockquote><p>不同图形的参数空间不同<br>参数空间中的一个点可以表示原图像中的一个图形的所有信息  </p></blockquote><h1 id="检测直线"><a href="#检测直线" class="headerlink" title="检测直线"></a>检测直线</h1><p>截距和斜率两个参数可以确定一条直线，但斜率无穷大甚至不存在时,无法在计算机中准确表示.所以在判定直线时,需要选定另一个参数空间</p><div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/e/e6/R_theta_line.GIF" alt="霍夫变换检测直线使用的参数空间"><br></div><p>$$r=x\cos \theta +y\sin \theta$$</p><p>此时任意一条直线均可以用$r$(直线到圆心的距离)和$\theta$(嗯....不好描述看上图吧)唯一表示.</p><p>现在思考一个简单的问题，根据上述公式，已知两点$(x_1,y_1)$,$(x_2,y_2)$,能否确定$r$和$\theta$,$\theta\subseteq \left ( -\frac{\pi }{2} ,\frac{\pi }{2} \right )$.如果不知道怎么确定就洗洗睡吧</p><p>也就是说，若已知图像中有且仅有一条直线，且不考虑像素带来的偏差(即所有点的坐标都是实数),则可以根据(直线上的)两点确定直线的具体位置.</p><p>上述过程是求解一个二元一次方程组.方程组中的每个方程代表一条曲线.解为两条曲线交点.</p><div align="center"><br><img src="https://docs.opencv.org/2.4/_images/Hough_Lines_Tutorial_Theory_1.jpg" alt="一个点在参数空间代表的曲线"><br></div><p>如果在同一条直线上选取三个点,三个点在参数空间做出的曲线必然相交与同一点，且该点表示原图像中的一条直线.以此类推,原图中同一直线上所有点在参数空间中做出的所有曲线必定相交与一点</p><div align="center"><br><img src="https://docs.opencv.org/2.4/_images/Hough_Lines_Tutorial_Theory_2.jpg" alt="多条曲线在参数空间的交点"><br></div><p>以上讨论是基于所有坐标均为实数,在实际中,像素为整数,无法在参数空间做出一条真正连续的曲线,最精确的近似是在参数空间做出连续的像素点.所以要将上述连续过程离散化.离散化后的曲线所经过的像素点,就是其投票的点.多条曲线的交点,必然是得票数最高的点.用得票数最高的点代替连续曲线的交点,此时该点为检测出的直线对应的参数点.至此,完成直线检测</p><p>因为存在误差,所以投票后的点会集中在一个区域,而不是某个特定的点,这也就解释了为什么会检测出多条几乎重叠的曲线.</p><p>上述描述中,基于这样一个假设,即图像中的所有点非黑即白,现实中的图像并非如此,所以在霍夫变换检测前,一般先进行边缘检测,边缘检测后返回的图像就是非黑即白(是边缘,或者不是边缘).</p><h1 id="检测圆"><a href="#检测圆" class="headerlink" title="检测圆"></a>检测圆</h1><p>就像开头提到的,检测圆与检测直线有着不同的参数空间.其他过程与检测直线完全相同</p><div align="center"><br>$x=x_0+r\cos\theta$<br>$y=y_0+r\sin\theta$<br></div><p>我们假定知道所需检测的圆的半径$r$.以原图像中的点为圆心,以$r$为半径在参数空间做圆,投票最多的点即为圆心,因为已知半径,圆检测完成.<br>上述假设已知半径.实际使用中,只需给出半径的范围,并遍历之,在所有遍历结果中找投票数最大的,即为被检测的圆</p><p>下图中,半径为$r$的红圆为期待被检测到的圆,每个蓝色的圆均是以红圆周上的点为圆心,以$r$为半径得到的圆,重叠部分最多的点即为被检测圆的圆心.</p><div align="center"><br><img src="/20180415221531/circle.png" alt="检测圆"><br></div><h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><p>由于时间原因,此处仅给出openCV中霍夫变换检测<a href="https://github.com/opencv/opencv/blob/master/samples/python/houghlines.py" target="_blank" rel="noopener">直线</a>和<a href="https://github.com/opencv/opencv/blob/master/samples/python/houghcircles.py" target="_blank" rel="noopener">圆</a>的样例.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html" target="_blank" rel="noopener">Hough Line Transform</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">霍夫变换</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着人工智能的兴起，计算机视觉相关概念，如人脸识别、人脸检测逐渐进入大众视野。本篇文章介绍计算机视觉中最基础的知识，直线和圆的一种检测算法-霍夫变换。并在最后给出Python的样例代码。&lt;/p&gt;</summary>
    
    
    
    <category term="图像" scheme="https://blog.sugarmix.me/categories/%E5%9B%BE%E5%83%8F/"/>
    
    
    <category term="图像" scheme="https://blog.sugarmix.me/tags/%E5%9B%BE%E5%83%8F/"/>
    
    <category term="openCV" scheme="https://blog.sugarmix.me/tags/openCV/"/>
    
  </entry>
  
  <entry>
    <title>关系模式符合的范式</title>
    <link href="https://blog.sugarmix.me/20180319190418/"/>
    <id>https://blog.sugarmix.me/20180319190418/</id>
    <published>2018-03-19T11:04:18.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。</p><a id="more"></a><h1 id="按规范设计的好处"><a href="#按规范设计的好处" class="headerlink" title="按规范设计的好处"></a>按规范设计的好处</h1><p>减少冗余。设计不良的数据表，存在大量冗余数据，这些数据浪费磁盘空间，还会影响数据修改的效率。下文讲看到冗余的例子。</p><p>增强一致性。存在冗余数据越多，越容易造成数据不一致。接下来将逐渐增强对一致性的要求，不同层次的要求就出现了不同的范式。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><h2 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h2><p>若关系中的某一 <strong>属性组</strong> 的值能唯一的标识一个元组,而其任何真子集都不能再标识,则称该属性组为候选码。下文中不加解释的 <strong>码</strong> 即为候选码。</p><h2 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h2><p>包含在任意候选码中的属性</p><h2 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h2><p><a href="#候选码">候选码</a>中任选一组，均可作为主码。</p><h2 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h2><p>不包含在主码中的属性，选定主码后确定非主属性。</p><p><em><strong> 非主属性 不等于 不是主属性的属性 </strong></em></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>B可以由A导出.则B依赖A</p><p>$$<br>A \to B<br>$$</p><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>B可以由A导出,并且不能由A的任意子集导出,则B完全函数依赖A</p><p>$$<br>(A \to B)\land(\lnot((\exists C \subsetneq A)\land(C \to B)))<br>$$</p><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>B可以由A导出,并且能由A的某个真子集导出,则B部分函数依赖A</p><p>$$<br>(A \to B)\land((\exists C \subsetneq B)\land(C \to B))<br>$$</p><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>B可以由A导出,C可以由B导出,则C传递函数依赖A</p><p>$$<br>(A \to B)\land(B \to C)<br>$$</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>域都应该是原子性的</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假如属性存在以下依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学号 → 学生姓名</span><br><span class="line">课程号 → 课程名 → 教材</span><br><span class="line">(学号,课程名) → 分数</span><br></pre></td></tr></table></figure><p>能放到数据库的信息都符合第一范式,下面给出一个符合第一范式的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成绩(学号,学生姓名,课程号,课程名,教材,分数)</span><br></pre></td></tr></table></figure><p>根据定义<br>主码:(学号,课程号)<br>非主属性:学生姓名,课程名,教材,分数</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在第一范式的基础上，非码属性必须完全依赖于<a href="#候选码">候选码</a>(在第一范式基础上消除<a href="#非主属性">非主属性</a>对<a href="#主码">主码</a>的<a href="#部分函数依赖">部分函数依赖</a>)</p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>学生姓名依赖学号却不依赖课程号,所以非主属性(学生姓名)部分依赖主码(学号,课程号).<br>修改第一范式的例子使其符合第二范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>任何非主属性不依赖于其它非主属性（在第二范式基础上消除<a href="#传递函数依赖">传递依赖</a>）</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p>在第二范式中的<code>课程(课程号,课程名,教材)</code>存在<code>课程号 → 课程名 → 教材</code>依赖关系,非主属性(教材)传递依赖非主属性(课程号).<br>修改例子使其满足第三范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名)</span><br><span class="line">教材(课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>在第三范式基础上，任何非主属性(其中包含主属性,神奇不神奇)不能对主码子集依赖(在第三范式基础上消除对主码子集的依赖).</p><p>知乎上大佬给出的一个更精确的定义:消除主属性对于码的部分与传递函数依赖.</p><p>因为第三范式已经解决其他依赖,此处只要解决那些原本可以被选为<strong>主码</strong>却沦为了<strong>非主属性</strong>的的<strong>主属性</strong>们,也就是说,此时,<strong>非主属性</strong>依旧是<strong>主属性</strong>.</p><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><p>下面这个例子抄自<a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">知乎</a><br>某公司有若干个仓库:</p><blockquote><p>每个仓库只能有一名管理员<br>一名管理员只能在一个仓库中工作<br>一个仓库中可以存放多种物品<br>一种物品也可以存放在不同的仓库中<br>每种物品在每个仓库中都有对应的数量</p></blockquote><p>关系<code>仓库(仓库名,管理员,物品名,数量)</code>符合第三范式</p><p>仓库 → 管理员<br>管理员 → 仓库<br>(仓库名,物品名) → 数量</p><p>若选(仓库名,物品名)为主码,则主属性(管理员)部分依赖主码(依赖主码中的仓库名)</p><p>修改关系使其符合BC范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仓库（仓库名，管理员）</span><br><span class="line">库存（仓库名，物品名，数量）</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">解释一下关系数据库的第一第二第三范式？ - 刘慰的回答 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎的特点</title>
    <link href="https://blog.sugarmix.me/20190225173604/"/>
    <id>https://blog.sugarmix.me/20190225173604/</id>
    <published>2019-02-25T09:36:09.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>每个MySQL存储引擎都满足特定需求。因此，引擎的选择主要取决于您希望在应用程序中完成的任务。</p><p>每个存储引擎的完整功能超出了本文的范围。我们将仅讨论各种存储引擎的不同以及它们的适应场景。</p><a id="more"></a><h1 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h1><p>InnoDB用于大多数数据库服务器，因为它支持事务，符合ACID。</p><p>原子性是增强数据库中数据的完整性的一种特性。当影响多个表的事务发生时，必须全部完成，否则回滚。</p><p>一致性意味着数据在保存到磁盘之前能够通过验证规则。</p><p>隔离性允许数据库隔离来自不同并发用户的事务。</p><p>持久性可确保在事务完成后被保存。</p><p>因此，如果您的应用程序需要上述功能，请选择InnoDB。</p><p>InnoDB的另一大优势是支持外键约束。这样可以保持所有相关数据库表的完整性。检查插入，更新和删除操作以确保多个表之间保持一致。</p><p>由于其持续改进，InnoDB不太容易发生数据库崩溃。如果在事务完成之前出现了问题，服务器重启后，InnoDB将完成操作或撤消更改。</p><p>InnoDB支持B-Tree索引和FULLTEXT索引，底层分别使用B-Tree和Inverted Lists实现。</p><h1 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h1><p>对于那些读取操作比写入操作更多的应用，MyISAM具有更好的性能。对于初学者来是很容易设计和创建一个数据库，因为它不支持外键(foreign keys)。使用外键需要有经验的配置来避免不合法的删除和更新操作。</p><p>与InnoDB相比，该引擎占用更少的磁盘空间，因此适用于磁盘空间受限制的应用。</p><p>MyISAM不符合ACID，因此它没有回滚功能。当事务失败时，必须手动删除数据。这个引擎支持并发插入操作。</p><p>MyISAM支持R-Tree索引。</p><h1 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h1><p>CSV代表逗号分隔值(Comma Separated Values)。这个引擎保存用逗号分割的明文数据。</p><p>当创建表格的时候会自动创建一个 <code>.CSV</code> 文件。</p><p>CSV文件的例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;75521&quot;,&quot;JOHN DOE&quot;</span><br><span class="line">&quot;75522&quot;,&quot;BABY DOE&quot;</span><br></pre></td></tr></table></figure><p>这个引擎的唯一优点是容易被Office软件读取。</p><p>CSV引擎不支持索引和事务，很少被使用。</p><h1 id="NDB存储引擎"><a href="#NDB存储引擎" class="headerlink" title="NDB存储引擎"></a>NDB存储引擎</h1><p>NDB 代表网络数据库(Network DataBase).它用于需要高级别可用性的集群环境中。NDB使用无共享体系结构，适用于创建分布式容错数据库体系结构。</p><p>如果你在运行一个至关重要(mission critical)的应用，并且数据需要冗余备份，选择NDB。然而，这个引擎需要一系列服务器来保存冗余数据。</p><p>大多数软件仓库的MySQL默认不安装这个引擎，需要下载MSQL社区版。</p><p>NDB具有InnoDB的大部分功能，可以扩展到128TB（7.5.2版本）。在线时间为99.999％，故障节点的恢复时间不到一秒。</p><h1 id="Blackhole存储引擎"><a href="#Blackhole存储引擎" class="headerlink" title="Blackhole存储引擎"></a>Blackhole存储引擎</h1><p>黑洞引擎接受数据并将其丢弃。您可以使用此存储引擎创建表并向其插入数据，但后续读取将返回空集。引擎支持索引。</p><p>Blackhole引擎可用于验证转储文件语法并测量二进制日志记录的开销，甚至可以查找数据库中的性能瓶颈。</p><h1 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h1><p>内存存储引擎用于将数据存储在内存中以用于特殊目的。使用此引擎容易崩溃，它的数据应该来源于其他永久存储的表。</p><p>内存存储引擎支持索引和加密。表中数据的大小受限于服务器上的可用内存。</p><p>可以使用此引擎存储非关键任务数据，例如会话(session)管理信息或只需最少更新的只读数据。请注意，重新启动服务器将擦除所有数据。</p><h1 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h1><p>如果你想在数据库中存储很多不常被使用的数据，例如历史信息，请使用存档存储引擎。该引擎使用非常小的空间中存储大量信息。</p><p>它支持压缩和加密，但缺少索引和事务功能。因此，它仅适用于归档数据，不应该被用于需要被快速更改、需要大量读写的信息。</p><h1 id="Federated存储引擎"><a href="#Federated存储引擎" class="headerlink" title="Federated存储引擎"></a>Federated存储引擎</h1><p>从没有集群和复制技术的远程MySQL服务器获取数据时，适合使用联合(Federated)存储引擎。</p><p>如果从使用联合引擎定义的本地表查询数据，则会从定义的远程服务器自动检索数据。因此，联合表需要本地和远程服务器。</p><p>远程服务器保存表定义和关联数据，而本地服务器仅保存包含指向远程服务器的连接字符串的定义。远程服务器上的存储引擎可以是任何类型，例如InnoDB或MyISAM。</p><p>MySQL默认不支持此引擎，使用需要启动。</p><p>联合存储引擎可以用作将数据写入远程服务器的代理。它只是一个指向远程服务器中另一个表的表。它应该很少被使用，因为它在连接表时非常慢并且在涉及事务时具有奇怪的行为。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://medium.com/@Alibaba_Cloud/how-to-choose-mysql-storage-engine-on-alibaba-cloud-d56687934c28" target="_blank" rel="noopener">How to Choose MySQL Storage Engine on Alibaba Cloud</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每个MySQL存储引擎都满足特定需求。因此，引擎的选择主要取决于您希望在应用程序中完成的任务。&lt;/p&gt;
&lt;p&gt;每个存储引擎的完整功能超出了本文的范围。我们将仅讨论各种存储引擎的不同以及它们的适应场景。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://blog.sugarmix.me/tags/MySQL/"/>
    
    <category term="翻译" scheme="https://blog.sugarmix.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
