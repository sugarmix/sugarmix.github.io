<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUGARMIX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sugarmix.me/"/>
  <updated>2020-05-17T17:13:38.639Z</updated>
  <id>https://blog.sugarmix.me/</id>
  
  <author>
    <name>sugarmix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Super Egg Drop</title>
    <link href="https://blog.sugarmix.me/20190315095242/"/>
    <id>https://blog.sugarmix.me/20190315095242/</id>
    <published>2019-03-15T01:52:51.000Z</published>
    <updated>2020-05-17T17:13:38.639Z</updated>
    
    <content type="html"><![CDATA[<p>鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><h1 id="正面解决"><a href="#正面解决" class="headerlink" title="正面解决"></a>正面解决</h1><p>即根据题目意思直接计算 F</p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>可以确定算法正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 没有鸡蛋或者没有楼层的时候肯定是 0  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 仅有一个鸡蛋，只能从最底层开始尝试，有几层就要尝试几次 */</span></span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 尝试最底层，如果鸡蛋没碎，确定结果；如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-1个楼层 */</span></span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * 尝试第i+1层，如果鸡蛋没碎，则问题转化为K个鸡蛋探索i层，即第一层到第i层(i-1+1)；</span></span><br><span class="line"><span class="comment">                 * 如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-i-1个楼层，即第i+2层到N层(N-(i+2)+1)；</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=3,N=26</p></blockquote><p>不出意外的超时了。</p><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>分析上述算法超时的原因，存在太多重复的递归运算，使用备忘录消除重复计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 备忘录 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] note = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.note[K][N] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果曾经计算过直接返回 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.note[K][N];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 返回前保存计算的值 */</span></span><br><span class="line">        <span class="keyword">this</span>.note[K][N] = t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=6,N=2000</p></blockquote><p>原本以为这样可以不优雅的通过，然而却依旧超时。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p>上述算法虽然消除了重复的递归运算，但依旧存在大量递归，递归本身消耗的时间太多，使用动态规划填表的方式消除递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 二维数组初始值为0 */</span></span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化1个鸡蛋i层楼尝试i次的情况 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化i个鸡蛋在1层楼尝试1次的情况 */</span></span><br><span class="line">            table[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始填表，思路同递归算法 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= N; n++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(table[k][<span class="number">0</span>], table[k - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                table[k][n] = t + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[K][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=7,N=10000</p></blockquote><p>意外的超时了。</p><h2 id="减少遍历"><a href="#减少遍历" class="headerlink" title="减少遍历"></a>减少遍历</h2><p>此处存在大量无价值的遍历，考虑到随着i增加，<code>table[k][i]</code>,<code>table[k - 1][n - i - 1]</code>分别单调增加和减少，故其两个中较大值，一定出现在中间位置。可以使用二分法找出最合适的<code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h1><p>K个鸡蛋，尝试M次，最多可以尝试到的楼层个数为<code>table[K][M]</code>。尝试某一层，若在该层碎了，则使用<code>K-1</code>个鸡蛋探索<code>M-1</code>次，若没碎，使用<code>K</code>个鸡蛋探索<code>M-1</code>次，当前探索的本层为<code>1</code>。虽然不知道尝试的哪一层，但是知道存在某一层，尝试后会得到的结果为<code>table[K][M]</code>。<br>当 <code>table[k][m-1] &lt; F &lt;= table[k][m]</code> 时，m即为探索的次数，注意鸡蛋可能给多了所以使用k而不是K，其中k&lt;=K。此时需要预估最大尝试次数M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = N;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="comment">/* 1个鸡蛋尝试i次 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">/* j个鸡蛋尝试1次 */</span></span><br><span class="line">            table[j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 策略是：尽可能的多使用鸡蛋，少使用尝试次数</span></span><br><span class="line"><span class="comment">         * 故遍历时，内层遍历鸡蛋，让鸡蛋先用完，</span></span><br><span class="line"><span class="comment">         * 外层遍历尝试次数，不得已的时候增加尝试次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                table[j][i] = table[j - <span class="number">1</span>][i - <span class="number">1</span>] + table[j][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[j][i] &gt;= N) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 楼层数为1,或鸡蛋数为1时会走到这里</span></span><br><span class="line"><span class="comment">         * 楼层数为1时返回1，鸡蛋数为1时返回楼层数</span></span><br><span class="line"><span class="comment">         * 综上返回楼层数即可</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，问题终于解决。最棒的情况是可以独立快速的解决问题，在认真思考后依旧不能给出合适的答案时，寻求帮助也是个不错的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Super Egg Drop</a><br><a href="https://www.cnblogs.com/Phantom01/p/9490508.html" target="_blank" rel="noopener">Leetcode 887 Super Egg Drop(扔鸡蛋) DP</a><br><a href="https://leetcode.com/problems/super-egg-drop/solution/" target="_blank" rel="noopener">Super Egg Drop Solution</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.sugarmix.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://blog.sugarmix.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈交叉编译</title>
    <link href="https://blog.sugarmix.me/20200407163610/"/>
    <id>https://blog.sugarmix.me/20200407163610/</id>
    <published>2020-04-07T08:36:11.000Z</published>
    <updated>2020-04-21T15:55:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。</p><a id="more"></a><h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>首先简化编译的概念，这里不提编译预处理、词法分析、语法分析等等一系列的概念，<del>因为我也不知道自己是不是真的懂这些东西</del>，想了解这部分概念，可以去看编译原理相关的书籍。</p><p>这里把<strong>编译</strong>简单的理解为<strong>从一种字符串</strong>（例如C语言的源程序）到<strong>另一种字符串</strong>（与机器相关的二进制01字符串）的<strong>转化</strong>。</p><p>进行转化操作的，一般来说是一个软件（我们不应该忘记曾经在纸带上打孔的科学家们，他们将想法变成纸带上孔的过程，难道不是编译所做的事情吗），这个软件被称为编译器。</p><ul><li>一般情况下，写一段C程序，通过运行在x86机器上的编译器，编译出一个可以在x86上运行的程序。  </li><li>另一种情况，还是那一段C程序，通过运行在AArch64机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>这体现了C语言良好的跨平台特性，一段代码只需要分别编译就可以在两种架构的设备上运行。</p><p>然而，假如你现在手上的AArch64的机器内存很小，没有硬盘，它能做的事情只是以很低的功耗运行一些小型的软件，或者以任何理由导致它没有运行起一个编译器的能力，而凑巧的是，你手头正好有一个可以用来编译的x86机器。（如果这个也没有，那你真的是太惨了）</p><p>现在第三种情况出现了</p><ul><li>还是刚才那段C程序，通过运行在x86机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>上面这个编译器，就被称为<strong>交叉编译器</strong>，这种情况，就被称为<strong>交叉编译</strong>。很显然，交叉编译器编译出的二进制文件没有办法在这台编译出它的机器上运行。</p><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>当我开开心心的把编译好的软件（此处应该理解为可执行文件），放到AArch64机器上运行的时候，告诉我缺少<code>lib*.so*</code>。出现这种情况<strong>一般</strong>是在编译时链接进来的库文件在目标系统（就是那个啥都没有还想运行软件的系统）上缺失。<br>一种方案是直接使用静态链接，这种方案不推荐。首要原因可以参考<a href="https://blog.lilydjwg.me/2015/5/11/why-i-m-against-static-linking.92218.html" target="_blank" rel="noopener">为什么我反对普遍地静态链接？-依云&#39;s Blog</a>，其次是，静态链接你真不见得编译的过 ;-)</p><h1 id="动态链接库的查找方式"><a href="#动态链接库的查找方式" class="headerlink" title="动态链接库的查找方式"></a>动态链接库的查找方式</h1><p>既然我们<del>菜的没法通过静态链接，</del>理智的接受了别人推荐的动态链接，那么就有必要知道二进制程序在运行时是如何查找所需要的链接库的。</p><p>直接放（在Linux可用的）结论。排名分先后</p><ol><li><p>Linux中二进制文件使用ELF格式，其中包含RPATH变量，这个变量指向一个路径，这个路径是这个二进制文件查找so的路径。在链接时可以通过环境变量或者编译参数影响这个变量，这是最稳妥也最有效果的方式，但是需要在编译时就确定好目录，如果程序已经编译完了，懒得再次编译或者无法再次编译，就不能用这个方法了</p></li><li><p>如果上一个步骤没有找到链接库，同时又设置了LD_LIBRARY_PATH环境变量，那么会在这个环境变量指向的路径中查找。这是我个人最常用也最喜欢的方式，使用的时候甚至不需要export，而是直接加在命令前面，可以把影响范围缩小到仅一条命令</p></li><li><p>第三种是使用/etc/ld.so.conf，在第二种方式查找失败的时候会使用中指定的路径</p></li></ol><p>除了第一种，剩下两种都有一定的约束条件，毕竟平白无辜设置一个环境变量二进制程序也不会去直接读。那么就要简单的说一下后两种是怎么生效的。在理解生效方式后，也就理解为什么也可以把so直接放到/lib或者/usr/lib里了。</p><p>算了，我懒了，这里直接贴<a href="http://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener">man ld.so</a>的输出</p><blockquote><p>When resolving shared object dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (this can occur if a shared object pathname containing slashes was specified at link time).  If a slash is found, then the dependency string is interpreted as a (relative or absolute) pathname, and the shared object is loaded using that pathname.</p><p> If a shared object dependency does not contain a slash, then it is searched for in the following order:</p><ul><li><p>Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist.  Use of DT_RPATH is deprecated.</p></li><li><p>Using the environment variable LD_LIBRARY_PATH, unless the executable is being run in secure-execution mode (see below), in which case this variable is ignored.</p></li><li><p>Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present.  Such directories are searched only to find those objects required by DT_NEEDED (direct dependencies) entries and do not apply to those objects&#39; children, which must themselves have their own DT_RUNPATH entries.  This is unlike DT_RPATH, which is applied to searches for all children in the dependency tree.</p></li><li><p>From the cache file /etc/ld.so.cache, which contains a compiled list of candidate shared objects previously found in the augmented library path.  If, however, the binary was linked with the -z nodeflib linker option, shared objects in the default paths are skipped.  Shared objects installed in hardware capability directories (see below) are preferred to other shared objects.</p></li><li><p>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</p></li></ul></blockquote><p>其中，刷新/etc/ld.so.cache的是/sbin/ldconfig。</p><p>手册可真是个好东西呀，这篇文章只是粗略的描述了一下，需要了解细节可以通过手册一层一层的查下去了。</p><p>本文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关系模式符合的范式</title>
    <link href="https://blog.sugarmix.me/20180319190418/"/>
    <id>https://blog.sugarmix.me/20180319190418/</id>
    <published>2018-03-19T11:04:18.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。</p><a id="more"></a><h1 id="按规范设计的好处"><a href="#按规范设计的好处" class="headerlink" title="按规范设计的好处"></a>按规范设计的好处</h1><p>减少冗余。设计不良的数据表，存在大量冗余数据，这些数据浪费磁盘空间，还会影响数据修改的效率。下文讲看到冗余的例子。</p><p>增强一致性。存在冗余数据越多，越容易造成数据不一致。接下来将逐渐增强对一致性的要求，不同层次的要求就出现了不同的范式。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><h2 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h2><p>若关系中的某一 <strong>属性组</strong> 的值能唯一的标识一个元组,而其任何真子集都不能再标识,则称该属性组为候选码。下文中不加解释的 <strong>码</strong> 即为候选码。</p><h2 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h2><p>包含在任意候选码中的属性</p><h2 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h2><p><a href="#候选码">候选码</a>中任选一组，均可作为主码。</p><h2 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h2><p>不包含在主码中的属性，选定主码后确定非主属性。</p><p><em><strong> 非主属性 不等于 不是主属性的属性 </strong></em></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>B可以由A导出.则B依赖A</p><p>$$<br>A \to B<br>$$</p><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>B可以由A导出,并且不能由A的任意子集导出,则B完全函数依赖A</p><p>$$<br>(A \to B)\land(\lnot((\exists C \subsetneq A)\land(C \to B)))<br>$$</p><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>B可以由A导出,并且能由A的某个真子集导出,则B部分函数依赖A</p><p>$$<br>(A \to B)\land((\exists C \subsetneq B)\land(C \to B))<br>$$</p><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>B可以由A导出,C可以由B导出,则C传递函数依赖A</p><p>$$<br>(A \to B)\land(B \to C)<br>$$</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>域都应该是原子性的</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>假如属性存在以下依赖关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学号 → 学生姓名</span><br><span class="line">课程号 → 课程名 → 教材</span><br><span class="line">(学号,课程名) → 分数</span><br></pre></td></tr></table></figure><p>能放到数据库的信息都符合第一范式,下面给出一个符合第一范式的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成绩(学号,学生姓名,课程号,课程名,教材,分数)</span><br></pre></td></tr></table></figure><p>根据定义<br>主码:(学号,课程号)<br>非主属性:学生姓名,课程名,教材,分数</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在第一范式的基础上，非码属性必须完全依赖于<a href="#候选码">候选码</a>(在第一范式基础上消除<a href="#非主属性">非主属性</a>对<a href="#主码">主码</a>的<a href="#部分函数依赖">部分函数依赖</a>)</p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>学生姓名依赖学号却不依赖课程号,所以非主属性(学生姓名)部分依赖主码(学号,课程号).<br>修改第一范式的例子使其符合第二范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>任何非主属性不依赖于其它非主属性（在第二范式基础上消除<a href="#传递函数依赖">传递依赖</a>）</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p>在第二范式中的<code>课程(课程号,课程名,教材)</code>存在<code>课程号 → 课程名 → 教材</code>依赖关系,非主属性(教材)传递依赖非主属性(课程号).<br>修改例子使其满足第三范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学生(学号,学生姓名)</span><br><span class="line">课程(课程号,课程名)</span><br><span class="line">教材(课程名,教材)</span><br><span class="line">成绩(学号,课程号,分数)</span><br></pre></td></tr></table></figure><h1 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>在第三范式基础上，任何非主属性(其中包含主属性,神奇不神奇)不能对主码子集依赖(在第三范式基础上消除对主码子集的依赖).</p><p>知乎上大佬给出的一个更精确的定义:消除主属性对于码的部分与传递函数依赖.</p><p>因为第三范式已经解决其他依赖,此处只要解决那些原本可以被选为<strong>主码</strong>却沦为了<strong>非主属性</strong>的的<strong>主属性</strong>们,也就是说,此时,<strong>非主属性</strong>依旧是<strong>主属性</strong>.</p><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><p>下面这个例子抄自<a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">知乎</a><br>某公司有若干个仓库:</p><blockquote><p>每个仓库只能有一名管理员<br>一名管理员只能在一个仓库中工作<br>一个仓库中可以存放多种物品<br>一种物品也可以存放在不同的仓库中<br>每种物品在每个仓库中都有对应的数量</p></blockquote><p>关系<code>仓库(仓库名,管理员,物品名,数量)</code>符合第三范式</p><p>仓库 → 管理员<br>管理员 → 仓库<br>(仓库名,物品名) → 数量</p><p>若选(仓库名,物品名)为主码,则主属性(管理员)部分依赖主码(依赖主码中的仓库名)</p><p>修改关系使其符合BC范式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">仓库（仓库名，管理员）</span><br><span class="line">库存（仓库名，物品名，数量）</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">解释一下关系数据库的第一第二第三范式？ - 刘慰的回答 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做事情都要有其特定的规范，按照规范做事，可以避免再去踩前辈们踩过的坑。本文将讨论在数据库设计时，应该遵循的规范。符合规范的层次越高，设计越复杂。真正使用时，需要考虑项目本身的复杂度，权衡好利弊。并不一定符合的层次越高，就是越好的设计。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>内存数据存储系统Redis与Memcached对比</title>
    <link href="https://blog.sugarmix.me/20190220102211/"/>
    <id>https://blog.sugarmix.me/20190220102211/</id>
    <published>2019-02-20T02:22:11.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>Redis和Memcached都是内存数据存储系统。Redis将大部分数据存储在内存中。它支持多种数据类型，包括字符串，哈希表和链列等。在本文中，我们将研究Redis和Memcached之间的区别。</p><a id="more"></a><h1 id="功能比较"><a href="#功能比较" class="headerlink" title="功能比较"></a>功能比较</h1><p>Redis的作者对Redis和Memcached有如下比较：</p><blockquote><p><strong><em>服务器端数据操作</em></strong><br>Redis拥有更多数据结构，支持服务端(Redis服务)直接对数据进行操作(如对整数的+1和-1操作)。对于类似的操作，在Memcached中，需要将数据复制到客户端，修改后，在服务端(Memcached服务)重新设置该值。这极大地增加了网络IO。在Redis中，这些复杂的操作与一般的GET/SET操作一样高效。因此，如果您需要缓存来支持更复杂的结构和操作，Redis是一个不错的选择。</p></blockquote><blockquote><p><strong><em>内存使用效率比较</em></strong><br>由于使用了简单的键值存储，Memcached具有更高的内存利用率。但是，如果Redis采用哈希结构，由于其组合压缩模式，它将具有比Memcached更高的内存利用率。</p></blockquote><blockquote><p><strong><em>性能比较</em></strong><br>Redis仅使用单核，而Memcached使用多核。因此，在一般情况下，就核心而言，Redis在小型数据存储方面的性能高于Memcached。在存储10万(100k)条及以上的数据时，Memcached优于Redis。虽然Redis也对存储大数据进行了一些优化，但它仍然不如Memcached。</p></blockquote><p>现在做一些支持上述观点的讨论。</p><h1 id="对不同数据类型的支持"><a href="#对不同数据类型的支持" class="headerlink" title="对不同数据类型的支持"></a>对不同数据类型的支持</h1><p>Memcached仅支持简单键值结构的数据记录，Redis支持更丰富的数据类型，包括String，Hash，List，Set和Sorted Set。Redis在内部使用redisObject来表示所有键和值。redisObject的主要信息如下所示：<br><img src="/20190220102211/redis_core_object.png" alt><br>该类型表示值对象的数据类型。编码指示Redis中不同数据类型的存储方法，例如type = string表示该值存储一般字符串，相应的编码可以是raw或int。如果为int，则Redis将关联的字符串存储并表示为值类型。当然，前提是可以用值表示字符串，例如字符串“123”和“456”。只有启用Redis虚拟内存功能后，才会为内存分配vm字段。默认情况下此功能处于关闭状态。现在让我们讨论一些数据类型。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>常用命令：</strong>set/get/decr/incr/mget等。<br><strong>应用场景：</strong>String是最常见的数据类型，通用key/value属于此类别。<br><strong>实现方法：</strong>String是字符串，redisObject默认情况下使用String(被保存的数据都被视为字符串)。当调用INCR或DECR操作时，系统会将其转换为值类型以进行计算(只有进行数值计算时，才将字符串类型转换为数值类型)。此时，redisObject的编码字段为int。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><strong>常用命令：</strong>hget/hset/hgetall等。<br><strong>应用场景：</strong>存储用户信息对象数据，包括用户ID，用户名，年龄和生日;通过用户ID检索用户名，年龄或生日。<br><strong>实现方法：</strong>Redis中的Hash是内部存储值的HashMap，并提供直接访问此map成员的接口。如图所示，Key是用户ID，Value是map。此映射的键是成员属性名称，值是属性值。通过这种方式，可以直接执行更改并通过内部映射的键访问数据（在Redis中，内部映射键称为字段），即通过密钥（用户ID）+字段（属性标记）到对相应的属性数据执行操作。</p><p>当前HashMap有两种实现方式：当HashMap中只有少数成员时，Redis会选择一维数组来实现紧凑存储以节省内存，而不是实际意义上的HashMap结构。此时，相应值redisObject的编码是zipmap。当成员数量增加时，Redis会将它们转换为真正意义上的HashMap，此时的编码将是ht。<br><img src="/20190220102211/hash.png" alt></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>常用命令：</strong>lpush/rpush/lpop/rpop/lrange。<br><strong>应用场景：</strong>Redis List是Redis中最重要的数据结构。实际上，可以使用Redis的list结构实现Twitter的following list和fans list 。<br><strong>实现方法：</strong>通过双向链表，支持反向查找和遍历以方便操作。但它也带来了一些额外的内存开销。Redis中的许多实现（包括发送缓冲队列）也采用此数据结构。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>常用命令：</strong>sadd/spop/smembers/sunion等。<br><strong>应用场景：</strong>Redis set提供了与list类似的外部列表功能。它的特殊之处在于set可以自动删除重复项。当您需要存储没有任何重复的数据list时，set是一个不错的选择。此外，set提供了一个重要的接口来判断一个成员是否在一个集合中，list不提供此功能。<br><strong>实现方法：</strong>set的内部实现是一个HashMap，其值始终为null。它实际上通过计算哈希值来快速删除重复项。实际上，这也是为什么set可以判断成员是否在集合内的原因。</p><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p><strong>常用命令：</strong>zadd/zrange/zrem/zcard等。<br><strong>应用场景：</strong>Redis Sorted Set(排序集)的应用场景与集合的应用场景类似。不同之处在于，set不会自动对数据进行排序，但是排序集可以通过用户提供的优先级参数对成员进行排序。而且，后者还会自动对插入的数据进行排序。当您需要一个没有重复数据的有序集合列表时，您可以选择Sorted Set数据结构，例如Twitter的公共时间线，它可以将发布时间作为优先级参数，并自动对按时间获取的数据进行排序。<br><strong>实现方法：</strong>Redis sorted set在内部使用HashMap和SkipList来确保高效的数据存储和排序。HashMap存储成员和优先级参数之间的映射;而SkipList存储所有成员。排序依赖于存储在HashMap中的优先级参数。使用SkipList结构可以提高搜索效率并简化实现。</p><h1 id="不同的内存管理方案"><a href="#不同的内存管理方案" class="headerlink" title="不同的内存管理方案"></a>不同的内存管理方案</h1><p>在Redis中，数据不一定完全保存在内存中。这是Redis和Memcached的主要区别。当物理内存已满时，Redis可能会将长时间未使用的值交换到磁盘。Redis仅缓存所有键(key)信息。如果发现内存使用率超过阈值，则会触发交换操作。Redis根据<code>swappability = age * log(size_in_memory)</code>计算要交换到磁盘的键的值。然后，将值保存到磁盘并从内存中擦除。此功能使Redis能够维护大于其机器内存容量的数据。机器内存必须保留所有键，并且不会把所有数据都交换到硬盘(内存中一定存在没有被交换的数据)。</p><p>当Redis进行数据交换时，提供服务的主线程和执行交换操作的子线程将共享这部分内存。此时Redis将阻止数据更新操作，直到子线程完成交换操作。当从Redis读取数据时，如果读取键对应的值不在内存中，则Redis需要从交换文件加载相应的数据，然后将其返回给请求者。这里存在I/O线程池的问题。默认情况下，Redis会拥塞，也就是说，只有在成功加载所有交换文件后才会响应。当有少量客户端时，此策略适用于成批操作。但是如果你在一个大型网站程序中应用Redis，它就无法满足高并发性要求。但是，可以设置Redis运行的I/O线程池大小，并使用并发读取加载位于交换文件的数据的请求，以缩短拥塞时间。</p><p>对于像Redis和Memcached这样基于内存的数据库系统，内存管理效率是影响系统性能的关键。在C语言中，malloc/free是最传统的分配和释放内存的方法。然而，这个方法隐藏了巨大的缺陷：首先，对于开发者来说，分配和释放不匹配很容易导致内存泄漏；其次，频繁的调用将使重新循环利用内存变得困难(内存碎片)，减少了内存的利用率；最后，系统调用将比一般函数调用消耗更大的系统开销。因此，为了提高内存管理效率，内存管理不会直接使用malloc/free调用作为解决方案。Redis和Memcached都采用他们自己设计的内存管理机制，但实现方法差异很大。接下来我们介绍这两种机制。</p><p>默认情况下，Memcached使用Slab Allocation机制进行内存管理。其主要思想是将分配的内存分段为预定义的特定长度的块，用这些块来存储长度相匹配的键值数据记录，以完全解决内存片段(外碎片)问题。理想状态下，slab的分配机制设计应该满足外部数据存储的需求，也就是说，它有助于在Slab Allocation系统中存储所有不同长度的键值数据。但是，Memcached的其他内存请求申请是通过一般的malloc/free调用发生的。通常，这些请求的数量小，频率低，不会影响整体系统性能。Slab Allocation的原理非常简单。首先它从操作系统申请一大块内存，把他们分成一系列大小不同的小块，然后把相同大小的小块放到Slab Class中。其中，块是用于存储键值数据的最小单元。通过在Memcached启动时创建增长因子，可以控制每个Slab类的大小。假设图中的生长因子是1.25。如果第一组中的块大小为88字节，则第二组中的块将为112字节。其余的块遵循相同的规则。<br><img src="/20190220102211/slab_class.png" alt><br>当Memcached接收到客户端发送的数据时，首先根据数据大小选择最合适的Slab Class，然后在Memcached中查询包含Slab Class的空闲块列表，以找到用于存储数据的块。当一段数据过期或废弃被丢弃时，回收占用的块，并将其恢复到空闲列表。</p><p>从上面的过程中，我们可以看到Memcached具有非常高的内存管理效率，不会导致内存碎片。然而，它最大的缺点是它可能造成空间浪费。由于操作系统会在特定长度的内存空间中分配每个块，因此较长的数据可能无法完全利用该空间。如图所示，当我们将100字节的数据缓存到128字节的块中时，未使用的28字节会浪费掉。<br><img src="/20190220102211/memcached_mem_waste.png" alt></p><p>Redis的内存管理的实现主要通过源代码中的两个文件zmalloc.h和zmalloc.c来完成。为了便于内存管理，Redis会在内存分配后将内存大小存储在内存块头中。如图所示，real_ptr是Redis调用malloc后返回的指针。Redis将内存块大小存储在头中，并且内存占用的大小是可确定的，即系统返回size_t类型的长度，然后返回ret_ptr。当需要释放内存时，系统将ret_ptr传递给内存管理程序。通过ret_ptr，程序可以轻松计算real_ptr的值，然后通过real_ptr释放内存。<br><img src="/20190220102211/redis_mem.png" alt><br>Redis通过定义长度为ZMALLOC_MAX_ALLOC_STAT的数组来记录所有内存的分布。数组中的每个元素表示当前程序分配的内存块数，内存块的大小是元素的下标。在源代码中，此数组是zmalloc_allocations。zmalloc_allocations[16]表示以16字节长度分配的内存块数。zmalloc.c包含一个used_memory的静态变量，用于记录当前分配的内存的总大小。所以一般来说，Redis采用封装的malloc/free，与Memcached的内存管理机制相比要简单得多。</p><h1 id="数据持久性支持"><a href="#数据持久性支持" class="headerlink" title="数据持久性支持"></a>数据持久性支持</h1><p>虽然是基于内存的存储，但Redis支持内存数据持久性，并提供两种主要的持久性策略：RDB快照和AOF日志。Memcached不支持数据持久性操作。</p><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>Redis支持将当前数据的快照存储到数据文件中以实现持久性，即RDB快照。但是，我们如何为连续写入数据的数据库生成快照呢？Redis利用fork命令的copy on write机制。在创建快照时，当前进程会fork一个子进程，使所有数据循环并将它们写入RDB文件。我们可以通过Redis的save命令配置RDB快照生成的时间。例如，如果要每10分钟配置一次快照生成，则可以在每1,000次写入后配置快照生成。您还可以配置多个规则以便一起实施。这些规则的定义在Redis的配置文件中。您还可以在Redis运行期间使用Redis的CONFIG SET命令设置规则，而无需重新启动Redis。</p><p>Redis的RDB文件在某种程度上是不可破坏的，因为它在新进程中执行其写操作。生成新的RDB文件后，Redis生成的子进程将首先将数据写入临时文件，然后通过原子重命名系统调用将临时文件重命名为RDB文件，以便RDB文件在Redis发生错误后始终可用。同时，Redis的RDB文件也是Redis主从同步内部实现的一个链接。但是，RDB的缺点在于，一旦数据库遇到某些问题，保存在RDB文件中的数据可能不是最新的，从最后一个RDB文件生成到Redis失败期间数据丢失。请注意，对于某些企业来说，这是可以容忍的。</p><h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><p>AOF日志的全程是 Append Only File。它是一个附加的日志文件。与通用数据库的binlog不同，AOF是一个可识别的明文(recognizable plaintext)，其内容是Redis标准命令。Rdeis仅把引起数据更改的命令添加到AOF。每个更改数据的命令都会生成一个日志。AOF文件将变得越来越大。Redis提供了另一个功能-AOF重写。AOF重写的功能是重新生成AOF文件。新AOF文件中，每条记录只有一个操作，而不像在旧的AOF文件中那样，记录了对同一个值的多次操作。生成过程类似于RDB快照，即分支进程，遍历数据并将数据写入新的临时AOF文件。将数据写入新文件时，它会将所有写操作日志写入旧的AOF文件，并同时将它们记录在内存缓冲区中。完成操作后，系统会一次将缓冲区中的所有日志写入临时文件。此后，它将调用atomic rename命令以使用新的AOF文件替换旧的AOF文件。</p><p>AOF是写文件操作，旨在将操作日志写入磁盘。它还涉及我们前面提到的写操作过程。在Redis调用AOF的写入操作后，它使用appendfsync选项通过调用fsync命令来控制将数据写入磁盘的时间。以下appendfsync中的三个设置选项具有从低到强的安全强度。</p><ul><li><p>appendfsync no：当我们将appendfsync设置为no时，Redis不会主动调用fsync来将AOF日志同步到磁盘。同步将完全依赖于操作系统调试。大多数Linux操作系统每30秒执行一次fsync操作，以将缓冲区中的数据写入磁盘。</p></li><li><p>appendfsync everysec：当我们将appendfsync设置为everysec时，Redis将默认每隔一秒调用一次fsync，以将缓冲区中的数据写入磁盘。但是当fsync调用持续时间超过1秒时，Redis将采用fsync延迟等待一秒钟。也就是说，Redis将在两秒后调用fsync。无论执行多长时间，它都将执行此fsync。此时，由于文件描述符在文件fsync期间会遇到拥塞，因此当前的写操作将遇到类似的拥塞。结论是，在绝大多数情况下，Redis将每隔一秒执行一次fsync。在最坏的情况下，它将每两秒执行一次fsync操作。大多数数据库系统将此操作称为组提交，即将多个写入的数据组合在一起并一次将日志写入磁盘。</p></li><li>appednfsync always：当我们将appendfsync设置为always时，每次写操作都会调用fsync一次。这时，数据是最安全的。当然，由于它每次都执行fsync，因此会影响性能。</li></ul><p>对于一般业务需求，我们建议您使用RDB进行持久化，因为RDB开销远低于AOF日志。对于无法承受任何数据丢失风险的应用程序，我们建议您使用AOF日志。</p><h1 id="集群管理的差异"><a href="#集群管理的差异" class="headerlink" title="集群管理的差异"></a>集群管理的差异</h1><p>Memcached是一个全内存数据缓冲系统。虽然Redis支持数据持久性，但全内存是其高性能的本质。对于基于内存的存储，物理机的内存大小是系统的最大数据存储容量。如果要处理的数据大小超过单个计算机的物理内存大小，则需要构建分布式群集以扩展存储容量。</p><p>Memcached本身不支持分布式模式。您只能通过分布式算法(如Consistent Hash)在客户端实现Memcached的分布式存储。下图演示了Memcached的分布式存储实现架构。在客户端向Memcached集群发送数据之前，它首先通过嵌套分布式算法计算数据的目标节点，然后嵌套分布式算法直接将数据发送到节点进行存储。但是当客户端查询数据时，还需要计算用作查询数据位置的节点，然后直接将查询请求发送到节点以获取数据。<br><img src="/20190220102211/memcached_distribution.png" alt></p><p>与只能在客户端实现分布式存储的Memcached相比，Redis更喜欢在服务器端构建分布式存储。最新版本的Redis支持分布式存储。Redis Cluster是Redis的高级版本，可实现分布式存储并允许SPOF。它没有中心节点，能够进行线性扩展。下图提供了Redis Cluster的分布式存储架构。节点间通信遵循二进制协议，但节点 - 客户端通信遵循ASCII协议。在数据放置策略中，Redis Cluster将整个密钥数值范围划分为4,096个散列槽，并允许在每个节点上存储一个或多个散列槽。也就是说，当前的Redis群集最多支持4,096个节点。Redis Cluster使用的分布式算法也很简单：crc16（key）％HASH_SLOTS_NUMBER。<br><img src="/20190220102211/redis_distribution.png" alt></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在本文中，我们讨论了Redis和Memcached之间的差异。我们首先列出了Redis的作者Salvatore Sanfilippo提出的几点比较。此后，我们进一步阐述了Redis和Memcached之间的关键点，即支持的数据类型，集群管理，数据持久性支持和内存管理方案。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>原文：<a href="https://medium.com/@Alibaba_Cloud/redis-vs-memcached-in-memory-data-storage-systems-3395279b0941" target="_blank" rel="noopener">Redis vs. Memcached: In-Memory Data Storage Systems</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis和Memcached都是内存数据存储系统。Redis将大部分数据存储在内存中。它支持多种数据类型，包括字符串，哈希表和链列等。在本文中，我们将研究Redis和Memcached之间的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.sugarmix.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://blog.sugarmix.me/tags/Redis/"/>
    
    <category term="Memcached" scheme="https://blog.sugarmix.me/tags/Memcached/"/>
    
    <category term="翻译" scheme="https://blog.sugarmix.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>批量修改Hexo文件名</title>
    <link href="https://blog.sugarmix.me/20181229230044/"/>
    <id>https://blog.sugarmix.me/20181229230044/</id>
    <published>2018-12-29T15:00:44.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知Hexo是个纯静态页面生成工具，使用<code>hexo new title</code>可生成标题为title的文章。若文章题目中出现中文，编码后肉眼不可识别中文意思；若不转码，中文作为url的一部分总会出现种种问题。本文将阐述解决上述问题的方法。</p><a id="more"></a><p>第一种，在创建文章的时候有意识的使用英文标题。第二中，使用当前时间作为文件名(即URL中的地址)，新建文件后再从文件中修改标题。</p><p>本文对第二种方法进行介绍，使用脚本创建新文章，注意时间是精确到秒，该脚本放在博客的根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=date +%Y%m%d%H%M%S</span><br><span class="line">hexo new <span class="string">"<span class="variable">$DATE</span>"</span></span><br><span class="line">vim <span class="built_in">source</span>/_posts/<span class="variable">$DATE</span>.md</span><br></pre></td></tr></table></figure><p>但是问题来了，如果已经写了很多很多的文章了，而且想批量修改成上述格式怎么办呢？下面给出批量修改文件名的脚本，将此脚本放到<code>_post</code>目录，执行即可，最终文件的格式将与上述格式相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ls | grep <span class="string">".md"</span> &gt; filename.txt</span><br><span class="line">num=`cat filename.txt|wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Start"</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=<span class="variable">$num</span>;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    filename=`cat filename.txt|awk NR==<span class="variable">$i</span>`</span><br><span class="line">    date=`cat <span class="variable">$filename</span>|grep <span class="string">"date: "</span>`</span><br><span class="line"></span><br><span class="line">    year=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 7-10`</span><br><span class="line">    mon=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 12-13`</span><br><span class="line">    day=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 15-16`</span><br><span class="line">    hour=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 18-19`</span><br><span class="line">    min=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 21-22`</span><br><span class="line">    sec=`<span class="built_in">echo</span> <span class="variable">$date</span>|cut -c 24-25`</span><br><span class="line"></span><br><span class="line">    oldname=`<span class="built_in">echo</span> <span class="variable">$&#123;filename%.md&#125;</span>`</span><br><span class="line">    newname=<span class="variable">$year</span><span class="variable">$mon</span><span class="variable">$day</span><span class="variable">$hour</span><span class="variable">$min</span><span class="variable">$sec</span></span><br><span class="line"></span><br><span class="line">    mv <span class="variable">$oldname</span> <span class="variable">$newname</span></span><br><span class="line">    mv <span class="variable">$oldname</span>.md <span class="variable">$newname</span>.md</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Renamed Number: <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Done"</span></span><br></pre></td></tr></table></figure><p>执行此脚本时，同时会重命名放图片的文件夹，若该文件夹不存在，则会有一系列输出，正常情况不要慌。</p><p>此时默认生成的链接里，会出现两部分日期，修改配置文件<code>_config.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :title/</span><br></pre></td></tr></table></figure><p>因为修改了文章链接，所有依赖链接工作的工具都会收影响，比如访客计数，评论系统等等。</p><p>最后提一句，不要在Telegram里直接保存代码，bash中的反引号会被处理掉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知Hexo是个纯静态页面生成工具，使用&lt;code&gt;hexo new title&lt;/code&gt;可生成标题为title的文章。若文章题目中出现中文，编码后肉眼不可识别中文意思；若不转码，中文作为url的一部分总会出现种种问题。本文将阐述解决上述问题的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="网站" scheme="https://blog.sugarmix.me/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站" scheme="https://blog.sugarmix.me/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
