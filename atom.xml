<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUGARMIX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sugarmix.me/"/>
  <updated>2021-02-20T08:55:35.834Z</updated>
  <id>https://blog.sugarmix.me/</id>
  
  <author>
    <name>sugarmix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>庚子年年终总结</title>
    <link href="https://blog.sugarmix.me/20210220143927/"/>
    <id>https://blog.sugarmix.me/20210220143927/</id>
    <published>2021-02-20T06:39:28.000Z</published>
    <updated>2021-02-20T08:55:35.834Z</updated>
    
    <content type="html"><![CDATA[<p>又是一年，这一年发展偏离了我原本理想中的计划，工作或生活，好在目前看来结果是好的，也算是在不断调整计划的过程吧。</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在<a href="/20200131211617/">去年的文章里</a>提到，已经过了<strong>可以尽情试错</strong>的年龄。在原本的计划里，本应该平稳的度过一年，然而计划却总也赶不上变化，在这一年里还是搞出了一些事情。虽说在这个年龄应该求稳，但当意识到这种稳定不可持续，也该做出些改变。这种有计划有目的的改变，应该算作<strong>在必要时选择更优的策略</strong>，尽管这些选择可能要付出很大的代价。</p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>去年提到工作是一场交易，公平性是决定交易可否进行的条件。今天需要增加一个判断条件：工作的可持续性。</p><p>个人认为不可持续的一个极端例子，是工厂流水线上的工人。在市场的调节下，可以认为这类工作是相对公平的，但是在这种环境下持续工作几年以后呢？至少我不会乐观的认为我会成为厂长，毕竟工人那么多，厂长那么少，成为那个幸运儿的概率并不大。那么我就是那个因为劳动力不如新人而被淘汰的那个人。这类工作的特点是，只需要简单的培训（没有去过工厂，盲猜培训时间不超过一周）就可以上岗，员工有很强的可替代性（甚至替代员工的都不一定是人类）。</p><p>反观自己，去年从事的是一个可替代性很强的工作，虽然要好于流水线，但也好不到哪去。对于这个问题的解决方法是，增加工作的难度，我相信难度越大可替代性就越弱。虽然存在岗位少的问题，但这个问题就放在以后去解答吧（现在就有解法，只是不想写在这里）。有能力从事自认为更困难的工作以获得更高的回报，那就去做吧。在市场中，选择平稳安全难度低的工作才是对自己的不负责。</p><p>还有一些关于价值观的东西。对于公司来说，能有产出的团队才是好的团队，个人做出的贡献不是优先被考量的因素。而我，一个自私自利的人，想要达到的效果是，个人做出了努力，就能在团队的成果中有所体现。想象到的这样的团队，是《黑客与画家》里提到的，大家都是足够强的人，每个人做出的贡献能够被其他所有人看到，且直接反映到个人收益上。</p><p>以上就是我换工作的根本原因，以前的公司足够的好，但是，不适合我。</p><h1 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h1><p>总体上在执行去年写下的方案。不过去年在追求学习效率最大化的方法中，缺少了对人性的考虑。大概有时候为了一点责任感，会考虑暂时放弃自己的利益吧。</p><p>今年博客更新少了很多，主要是选择了用<a href="https://wiki.sugarmix.me/" target="_blank" rel="noopener">wiki</a>记录琐碎的知识。博客也不会被轻易抛弃，后续考虑把wiki里那些经过自己思考的内容迁移到博客上。</p><h1 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h1><p>过去一年的生活可以说是相当的精彩。然而不是所有的精彩都适合分享。内容不必说，分享一些感悟。</p><p>只有自己足够强了，才不会那么的在意得失。对于失去的，相信自己未来会有更好的。对于拥有的，也不必担心未来某一天会失去。过平淡的生活，做好自己此刻能做的事，不后悔过去，也不担忧未来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是一年，这一年发展偏离了我原本理想中的计划，工作或生活，好在目前看来结果是好的，也算是在不断调整计划的过程吧。&lt;/p&gt;</summary>
    
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/tags/%E9%BB%98%E8%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>《鲁迅全集》摘抄</title>
    <link href="https://blog.sugarmix.me/20201225125556/"/>
    <id>https://blog.sugarmix.me/20201225125556/</id>
    <published>2020-12-25T04:55:57.000Z</published>
    <updated>2020-12-25T05:31:15.993Z</updated>
    
    <content type="html"><![CDATA[<p>谁曾想一个工科学生在将来的某一天重读鲁迅，并愿意把它记录下来。</p><a id="more"></a><p>《端午节》</p><blockquote><p>人们是每苦于没有“自知之明”的。</p></blockquote><p>《影的告别》</p><blockquote><p>我不过一个影，要别你而沉默在黑暗里了。而然黑暗又会吞并我，然而光明又会使我消失。</p></blockquote><p>《希望》</p><blockquote><p>希望是甚么？是娼妓：她对谁都蛊惑，将一切都献给；待你牺牲了极多的宝贝——你的青春——她就弃掉你。</p></blockquote><p>《过客》</p><blockquote><p>倘使我得到了谁的布施，我就要想秃鹰看见死尸一样，在四近徘徊，祝愿她的灭亡，给我亲眼看见；或者诅咒她以外的一切全部灭亡，连我自己，因为我就应该得到诅咒。但我还没有这样的力量；即使有这力量，我也不愿意她有这样的境遇，因为他们大概总不愿意有这样的境遇。</p></blockquote><p>《随感录四十一》</p><blockquote><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。  </p><p>此后如竟没有炬火：我便是唯一的光。</p></blockquote><p>《六十二 恨恨而死》</p><blockquote><p>古来很有几位恨恨而死的人物。他们一面说些“怀才不遇”，“天道宁论”的话，一面有钱的便狂嫖滥赌，没钱的便喝几十碗酒，——因为不平的缘故，于是后来就恨恨而死了。</p><p>我们应该趁他们活着的时候问他：诸公！您知道北京离昆仑山几里，弱水去黄河几丈么？火药除了做鞭炮，罗盘除了看风水，还有什么用处么？棉花是红的还是白的？谷子是长在树上，还是长在草上？桑见濮上如何情形，自由恋爱怎样态度？您在半夜里可忽然觉得有些羞，清早上可居然有点悔么？四斤的担，您能挑么？三里的道，您能跑么？</p><p>他们如果细细的想，慢慢的悔了，这便很有些希望。万一越发不平，越发愤怒，那便“爱莫能助”。——于是他们终于恨恨而死了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;谁曾想一个工科学生在将来的某一天重读鲁迅，并愿意把它记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="默认" scheme="https://blog.sugarmix.me/tags/%E9%BB%98%E8%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Super Egg Drop</title>
    <link href="https://blog.sugarmix.me/20190315095242/"/>
    <id>https://blog.sugarmix.me/20190315095242/</id>
    <published>2019-03-15T01:52:51.000Z</published>
    <updated>2020-05-17T17:13:38.639Z</updated>
    
    <content type="html"><![CDATA[<p>鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><h1 id="正面解决"><a href="#正面解决" class="headerlink" title="正面解决"></a>正面解决</h1><p>即根据题目意思直接计算 F</p><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>可以确定算法正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 没有鸡蛋或者没有楼层的时候肯定是 0  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* 仅有一个鸡蛋，只能从最底层开始尝试，有几层就要尝试几次 */</span></span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 尝试最底层，如果鸡蛋没碎，确定结果；如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-1个楼层 */</span></span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * 尝试第i+1层，如果鸡蛋没碎，则问题转化为K个鸡蛋探索i层，即第一层到第i层(i-1+1)；</span></span><br><span class="line"><span class="comment">                 * 如果鸡蛋碎了，则问题转化为，K-1个鸡蛋探索N-i-1个楼层，即第i+2层到N层(N-(i+2)+1)；</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=3,N=26</p></blockquote><p>不出意外的超时了。</p><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><p>分析上述算法超时的原因，存在太多重复的递归运算，使用备忘录消除重复计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 备忘录 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] note = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.note[K][N] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果曾经计算过直接返回 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.note[K][N];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = Math.max(<span class="keyword">this</span>.superEggDrop(K, <span class="number">0</span>), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                t = Math.min(t, Math.max(<span class="keyword">this</span>.superEggDrop(K, i), <span class="keyword">this</span>.superEggDrop(K - <span class="number">1</span>, N - i - <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 返回前保存计算的值 */</span></span><br><span class="line">        <span class="keyword">this</span>.note[K][N] = t + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=6,N=2000</p></blockquote><p>原本以为这样可以不优雅的通过，然而却依旧超时。</p><h2 id="消除递归"><a href="#消除递归" class="headerlink" title="消除递归"></a>消除递归</h2><p>上述算法虽然消除了重复的递归运算，但依旧存在大量递归，递归本身消耗的时间太多，使用动态规划填表的方式消除递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 二维数组初始值为0 */</span></span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化1个鸡蛋i层楼尝试i次的情况 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="comment">/* 初始化i个鸡蛋在1层楼尝试1次的情况 */</span></span><br><span class="line">            table[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 开始填表，思路同递归算法 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= N; n++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(table[k][<span class="number">0</span>], table[k - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                table[k][n] = t + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table[K][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>K=7,N=10000</p></blockquote><p>意外的超时了。</p><h2 id="减少遍历"><a href="#减少遍历" class="headerlink" title="减少遍历"></a>减少遍历</h2><p>此处存在大量无价值的遍历，考虑到随着i增加，<code>table[k][i]</code>,<code>table[k - 1][n - i - 1]</code>分别单调增加和减少，故其两个中较大值，一定出现在中间位置。可以使用二分法找出最合适的<code>i</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = Math.min(t, Math.max(table[k][i], table[k - <span class="number">1</span>][n - i - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h1><p>K个鸡蛋，尝试M次，最多可以尝试到的楼层个数为<code>table[K][M]</code>。尝试某一层，若在该层碎了，则使用<code>K-1</code>个鸡蛋探索<code>M-1</code>次，若没碎，使用<code>K</code>个鸡蛋探索<code>M-1</code>次，当前探索的本层为<code>1</code>。虽然不知道尝试的哪一层，但是知道存在某一层，尝试后会得到的结果为<code>table[K][M]</code>。<br>当 <code>table[k][m-1] &lt; F &lt;= table[k][m]</code> 时，m即为探索的次数，注意鸡蛋可能给多了所以使用k而不是K，其中k&lt;=K。此时需要预估最大尝试次数M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = N;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span>[][] table = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="comment">/* 1个鸡蛋尝试i次 */</span></span><br><span class="line">            table[<span class="number">1</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">/* j个鸡蛋尝试1次 */</span></span><br><span class="line">            table[j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 策略是：尽可能的多使用鸡蛋，少使用尝试次数</span></span><br><span class="line"><span class="comment">         * 故遍历时，内层遍历鸡蛋，让鸡蛋先用完，</span></span><br><span class="line"><span class="comment">         * 外层遍历尝试次数，不得已的时候增加尝试次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                table[j][i] = table[j - <span class="number">1</span>][i - <span class="number">1</span>] + table[j][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (table[j][i] &gt;= N) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 楼层数为1,或鸡蛋数为1时会走到这里</span></span><br><span class="line"><span class="comment">         * 楼层数为1时返回1，鸡蛋数为1时返回楼层数</span></span><br><span class="line"><span class="comment">         * 综上返回楼层数即可</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，问题终于解决。最棒的情况是可以独立快速的解决问题，在认真思考后依旧不能给出合适的答案时，寻求帮助也是个不错的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">Super Egg Drop</a><br><a href="https://www.cnblogs.com/Phantom01/p/9490508.html" target="_blank" rel="noopener">Leetcode 887 Super Egg Drop(扔鸡蛋) DP</a><br><a href="https://leetcode.com/problems/super-egg-drop/solution/" target="_blank" rel="noopener">Super Egg Drop Solution</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸡蛋从楼上掉下来，在某层以上一定会破，在某层以及以下一定不会破，若鸡蛋破碎则不能再次使用，现在有K个鸡蛋N层楼，每次可以在某层楼扔一个鸡蛋探测，在最坏的情况下，至少需要多少次才能准确探测出在第几层鸡蛋会破碎？&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.sugarmix.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://blog.sugarmix.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈交叉编译</title>
    <link href="https://blog.sugarmix.me/20200407163610/"/>
    <id>https://blog.sugarmix.me/20200407163610/</id>
    <published>2020-04-07T08:36:11.000Z</published>
    <updated>2020-04-21T15:55:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。</p><a id="more"></a><h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>首先简化编译的概念，这里不提编译预处理、词法分析、语法分析等等一系列的概念，<del>因为我也不知道自己是不是真的懂这些东西</del>，想了解这部分概念，可以去看编译原理相关的书籍。</p><p>这里把<strong>编译</strong>简单的理解为<strong>从一种字符串</strong>（例如C语言的源程序）到<strong>另一种字符串</strong>（与机器相关的二进制01字符串）的<strong>转化</strong>。</p><p>进行转化操作的，一般来说是一个软件（我们不应该忘记曾经在纸带上打孔的科学家们，他们将想法变成纸带上孔的过程，难道不是编译所做的事情吗），这个软件被称为编译器。</p><ul><li>一般情况下，写一段C程序，通过运行在x86机器上的编译器，编译出一个可以在x86上运行的程序。  </li><li>另一种情况，还是那一段C程序，通过运行在AArch64机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>这体现了C语言良好的跨平台特性，一段代码只需要分别编译就可以在两种架构的设备上运行。</p><p>然而，假如你现在手上的AArch64的机器内存很小，没有硬盘，它能做的事情只是以很低的功耗运行一些小型的软件，或者以任何理由导致它没有运行起一个编译器的能力，而凑巧的是，你手头正好有一个可以用来编译的x86机器。（如果这个也没有，那你真的是太惨了）</p><p>现在第三种情况出现了</p><ul><li>还是刚才那段C程序，通过运行在x86机器上的编译器，编译出一个可以在AArch64上运行的程序。</li></ul><p>上面这个编译器，就被称为<strong>交叉编译器</strong>，这种情况，就被称为<strong>交叉编译</strong>。很显然，交叉编译器编译出的二进制文件没有办法在这台编译出它的机器上运行。</p><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>当我开开心心的把编译好的软件（此处应该理解为可执行文件），放到AArch64机器上运行的时候，告诉我缺少<code>lib*.so*</code>。出现这种情况<strong>一般</strong>是在编译时链接进来的库文件在目标系统（就是那个啥都没有还想运行软件的系统）上缺失。<br>一种方案是直接使用静态链接，这种方案不推荐。首要原因可以参考<a href="https://blog.lilydjwg.me/2015/5/11/why-i-m-against-static-linking.92218.html" target="_blank" rel="noopener">为什么我反对普遍地静态链接？-依云&#39;s Blog</a>，其次是，静态链接你真不见得编译的过 ;-)</p><h1 id="动态链接库的查找方式"><a href="#动态链接库的查找方式" class="headerlink" title="动态链接库的查找方式"></a>动态链接库的查找方式</h1><p>既然我们<del>菜的没法通过静态链接，</del>理智的接受了别人推荐的动态链接，那么就有必要知道二进制程序在运行时是如何查找所需要的链接库的。</p><p>直接放（在Linux可用的）结论。排名分先后</p><ol><li><p>Linux中二进制文件使用ELF格式，其中包含RPATH变量，这个变量指向一个路径，这个路径是这个二进制文件查找so的路径。在链接时可以通过环境变量或者编译参数影响这个变量，这是最稳妥也最有效果的方式，但是需要在编译时就确定好目录，如果程序已经编译完了，懒得再次编译或者无法再次编译，就不能用这个方法了</p></li><li><p>如果上一个步骤没有找到链接库，同时又设置了LD_LIBRARY_PATH环境变量，那么会在这个环境变量指向的路径中查找。这是我个人最常用也最喜欢的方式，使用的时候甚至不需要export，而是直接加在命令前面，可以把影响范围缩小到仅一条命令</p></li><li><p>第三种是使用/etc/ld.so.conf，在第二种方式查找失败的时候会使用中指定的路径</p></li></ol><p>除了第一种，剩下两种都有一定的约束条件，毕竟平白无辜设置一个环境变量二进制程序也不会去直接读。那么就要简单的说一下后两种是怎么生效的。在理解生效方式后，也就理解为什么也可以把so直接放到/lib或者/usr/lib里了。</p><p>算了，我懒了，这里直接贴<a href="http://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener">man ld.so</a>的输出</p><blockquote><p>When resolving shared object dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (this can occur if a shared object pathname containing slashes was specified at link time).  If a slash is found, then the dependency string is interpreted as a (relative or absolute) pathname, and the shared object is loaded using that pathname.</p><p> If a shared object dependency does not contain a slash, then it is searched for in the following order:</p><ul><li><p>Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist.  Use of DT_RPATH is deprecated.</p></li><li><p>Using the environment variable LD_LIBRARY_PATH, unless the executable is being run in secure-execution mode (see below), in which case this variable is ignored.</p></li><li><p>Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present.  Such directories are searched only to find those objects required by DT_NEEDED (direct dependencies) entries and do not apply to those objects&#39; children, which must themselves have their own DT_RUNPATH entries.  This is unlike DT_RPATH, which is applied to searches for all children in the dependency tree.</p></li><li><p>From the cache file /etc/ld.so.cache, which contains a compiled list of candidate shared objects previously found in the augmented library path.  If, however, the binary was linked with the -z nodeflib linker option, shared objects in the default paths are skipped.  Shared objects installed in hardware capability directories (see below) are preferred to other shared objects.</p></li><li><p>In the default path /lib, and then /usr/lib.  (On some 64-bit architectures, the default paths for 64-bit shared objects are /lib64, and then /usr/lib64.)  If the binary was linked with the -z nodeflib linker option, this step is skipped.</p></li></ul></blockquote><p>其中，刷新/etc/ld.so.cache的是/sbin/ldconfig。</p><p>手册可真是个好东西呀，这篇文章只是粗略的描述了一下，需要了解细节可以通过手册一层一层的查下去了。</p><p>本文完。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做一些跟软件跨平台相关的事情，对曾经一直以为高大上的交叉编译也有了初步的认识。至于为什么说高大上呢，编译这个词，就很神圣，毕竟《编译原理》不是用几天时间就可以高明白的东西。在编译前面再加一个更具迷惑性的交叉，就更让人摸不找头脑了。这篇文章主要谈一谈什么是交叉编译，以及在实践中遇到的一些小问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.sugarmix.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>霍夫变换检测原理及Python实现</title>
    <link href="https://blog.sugarmix.me/20180415221531/"/>
    <id>https://blog.sugarmix.me/20180415221531/</id>
    <published>2018-04-15T14:15:31.000Z</published>
    <updated>2020-04-07T08:02:20.251Z</updated>
    
    <content type="html"><![CDATA[<p>随着人工智能的兴起，计算机视觉相关概念，如人脸识别、人脸检测逐渐进入大众视野。本篇文章介绍计算机视觉中最基础的知识，直线和圆的一种检测算法-霍夫变换。并在最后给出Python的样例代码。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>霍夫变换用来检测物图像中的特征(例如直线和圆).算法如下：</p><blockquote><p>根据被检测的图形，寻找特定的参数空间<br>原图像中所有的点在参数空间中执行投票,投票结果最大的点，即为要寻找的图形</p></blockquote><p>根据上面的描述不难看出,一般情况下：</p><blockquote><p>不同图形的参数空间不同<br>参数空间中的一个点可以表示原图像中的一个图形的所有信息  </p></blockquote><h1 id="检测直线"><a href="#检测直线" class="headerlink" title="检测直线"></a>检测直线</h1><p>截距和斜率两个参数可以确定一条直线，但斜率无穷大甚至不存在时,无法在计算机中准确表示.所以在判定直线时,需要选定另一个参数空间</p><div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/e/e6/R_theta_line.GIF" alt="霍夫变换检测直线使用的参数空间"><br></div><p>$$r=x\cos \theta +y\sin \theta$$</p><p>此时任意一条直线均可以用$r$(直线到圆心的距离)和$\theta$(嗯....不好描述看上图吧)唯一表示.</p><p>现在思考一个简单的问题，根据上述公式，已知两点$(x_1,y_1)$,$(x_2,y_2)$,能否确定$r$和$\theta$,$\theta\subseteq \left ( -\frac{\pi }{2} ,\frac{\pi }{2} \right )$.如果不知道怎么确定就洗洗睡吧</p><p>也就是说，若已知图像中有且仅有一条直线，且不考虑像素带来的偏差(即所有点的坐标都是实数),则可以根据(直线上的)两点确定直线的具体位置.</p><p>上述过程是求解一个二元一次方程组.方程组中的每个方程代表一条曲线.解为两条曲线交点.</p><div align="center"><br><img src="https://docs.opencv.org/2.4/_images/Hough_Lines_Tutorial_Theory_1.jpg" alt="一个点在参数空间代表的曲线"><br></div><p>如果在同一条直线上选取三个点,三个点在参数空间做出的曲线必然相交与同一点，且该点表示原图像中的一条直线.以此类推,原图中同一直线上所有点在参数空间中做出的所有曲线必定相交与一点</p><div align="center"><br><img src="https://docs.opencv.org/2.4/_images/Hough_Lines_Tutorial_Theory_2.jpg" alt="多条曲线在参数空间的交点"><br></div><p>以上讨论是基于所有坐标均为实数,在实际中,像素为整数,无法在参数空间做出一条真正连续的曲线,最精确的近似是在参数空间做出连续的像素点.所以要将上述连续过程离散化.离散化后的曲线所经过的像素点,就是其投票的点.多条曲线的交点,必然是得票数最高的点.用得票数最高的点代替连续曲线的交点,此时该点为检测出的直线对应的参数点.至此,完成直线检测</p><p>因为存在误差,所以投票后的点会集中在一个区域,而不是某个特定的点,这也就解释了为什么会检测出多条几乎重叠的曲线.</p><p>上述描述中,基于这样一个假设,即图像中的所有点非黑即白,现实中的图像并非如此,所以在霍夫变换检测前,一般先进行边缘检测,边缘检测后返回的图像就是非黑即白(是边缘,或者不是边缘).</p><h1 id="检测圆"><a href="#检测圆" class="headerlink" title="检测圆"></a>检测圆</h1><p>就像开头提到的,检测圆与检测直线有着不同的参数空间.其他过程与检测直线完全相同</p><div align="center"><br>$x=x_0+r\cos\theta$<br>$y=y_0+r\sin\theta$<br></div><p>我们假定知道所需检测的圆的半径$r$.以原图像中的点为圆心,以$r$为半径在参数空间做圆,投票最多的点即为圆心,因为已知半径,圆检测完成.<br>上述假设已知半径.实际使用中,只需给出半径的范围,并遍历之,在所有遍历结果中找投票数最大的,即为被检测的圆</p><p>下图中,半径为$r$的红圆为期待被检测到的圆,每个蓝色的圆均是以红圆周上的点为圆心,以$r$为半径得到的圆,重叠部分最多的点即为被检测圆的圆心.</p><div align="center"><br><img src="/20180415221531/circle.png" alt="检测圆"><br></div><h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><p>由于时间原因,此处仅给出openCV中霍夫变换检测<a href="https://github.com/opencv/opencv/blob/master/samples/python/houghlines.py" target="_blank" rel="noopener">直线</a>和<a href="https://github.com/opencv/opencv/blob/master/samples/python/houghcircles.py" target="_blank" rel="noopener">圆</a>的样例.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html" target="_blank" rel="noopener">Hough Line Transform</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">霍夫变换</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着人工智能的兴起，计算机视觉相关概念，如人脸识别、人脸检测逐渐进入大众视野。本篇文章介绍计算机视觉中最基础的知识，直线和圆的一种检测算法-霍夫变换。并在最后给出Python的样例代码。&lt;/p&gt;</summary>
    
    
    
    <category term="图像" scheme="https://blog.sugarmix.me/categories/%E5%9B%BE%E5%83%8F/"/>
    
    
    <category term="图像" scheme="https://blog.sugarmix.me/tags/%E5%9B%BE%E5%83%8F/"/>
    
    <category term="openCV" scheme="https://blog.sugarmix.me/tags/openCV/"/>
    
  </entry>
  
</feed>
